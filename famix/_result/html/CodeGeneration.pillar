{
	"profile" : [
		{
			"name": "Moose",
	 		"avatar": "moose-icon.png",
     			"post": "Famix",
     			"firm": "General purpose meta-models building framework"
		}
	]

}

!Code generation
@ch:CodeGeneration

!!Code generators
@ch:codeGenerators

Most of the meta-models for programming languages share the same basic structure. In most cases, you have entities that have a name, some related source code and so on. For more convinient definition of such meta-models, th Moose provides several predefined templates. 

!!!FamixBasicInfrastructureGenerator

The ==FamixBasicInfrastructureGenerator== should be used for meta-models that will store the source code information directly in the model in the text form and will not use external file references for this purpose.

+Basic infrastructure generator>Chapters/CodeGeneration/figures/BasicInfrastructureGenerator.svg|width=60|label=fig:FamixBasicInfrastructureGenerator+

|!entity|!description
| Entity | root entity of the meta-model
| SourcedEntity | entity with associated source code anchor
| SourceAnchor | abstract kind of a source anchor
| SourceTextAnchor | anchor with source code stored directly in the entity
| SourceLanguage | description of the source language
| Comment | comment entity
| NamedEntity | entity with a name


!!!FamixFileBasedLanguageGenerator

The ==FamixFileBasedLanguageGenerator== is and extension of ==FamixBasicInfrastructureGenerator== designed to produce a basic template for language meta-models that have source codes stored in files.

+File based language generator>Chapters/CodeGeneration/figures/FileBasedLanguageGenerator.svg|width=95|label=fig:FileBasedLanguageGenerator+

|!entity|!description
| AbstractFileAnchor | provides basic infrmation like name about file
| FileAnchor | refers to source code position in terms of lines/columns
| IndexedFileAnchor | stores source code positions as indexes in the file
| MultipleFileAnchor | for entities that are defined in multiple files
| AbstractFile | abstract file system entity
| File | file entity that contains language entities
| Folder | folder entity that contains files and other folders


!!Code generation management
@ch:codeGenerationManagement

When we want to build our metamodel as extension of some already existing metamodel, we need to know the elements of the existing metamodel but do not generate it.

[[[­lan­gua­ge=­Sma­lltalk
builder doNotGenerateCurrent.
]]]


!!Creation of a builder

@ch:creationOfABuilder

The primary class of the metamodel builder is named ==FamixMetamodelBuilder==. There are several ways how instances of this class can be created. 

!!!Builder for real environment

If builders are created using the standard ==new== message sent to the ==FamixMetamodelBuilder== class, builder will work on real environment (implemented in class FamixMetamodelBuilderRealEnvironment). That means that all classes generated by the builder will be installed directly to the Pharo image and models can be instantiated from them.

[[[­lan­gua­ge=­Sma­lltalk
builder := FamixMetamodelBuilder new.
]]]

!!!Builder for testing environment

The other option is to create a builder that is bound to a ''Ring'' environment, and all generated classes a part of this environment. It is used mainly for testing purposes because it does not modify any classes in the system, it is faster and the tests do not need to do a difficult cleanup. Such generated ''Ring'' environments can be used for other purposes like the direct export of the generated package too. 

On the other hand, it is not possible to instantiate such generated classes so no real model can be created from them.

[[[­lan­gua­ge=­Sma­lltalk
builder := FamixMetamodelBuilder forTesting.
]]]

!!!Class tags

By default, the classes are generated with a tag ''Entities'' so in our case, the classes are placed in a category named ''SQL-Metamodel-Entities''. The traits generated by the builder have a tag 'Traits'. The names of tags for entities and traits can be modified using messages ==classTag:== and ==traitTag:== sent to the builder. They are valid from this point for all the future specified classes or traits. 

The tag can be set for classes and traits individually using the message ==tag:==

!!!Basic superclasses

When a generalization of a class is not specified, a default superclass is used (==MooseEntity==). When the builder is used for generation of meta-models independent of Moose, or if the builder serves for generation of a meta-model which extends another meta-model, some other class can be selected as a default superclass (message ==basicSuperclassName:==).

For stateful traits (that mostly look as standard classes) a default superclass is different. It can be set using the message ==defaultBasicTraitName:== and the default value is ==Trait==. It is not recommended to change it. 

Keep in mind that the basic superclasses and traits are expected to provide some behavior (e.g. class slots initialization) so be careful when you change them.

!!!The composition of multiple meta-models

In many cases, we want to be able to use several meta-models in one model. We may need it if:

- the programs we want to model are written in several languages
- the programs use embedded code inside the source code of standard entities, like SQL queries in form of strings inside the Java methods
- models embed submodels with a different abstraction. The typical example can be models of the abstract syntax tree that is linked with the language meta-model

The common characteristic of the cases above is that the meta-models are more or less standalone. The models created using multiple meta-models are in fact independent models and we want to work with them this way. The meta-models are created separately too within standalone packages. We just want the ability to link information in one model to another model with different meta-model.

Unfortunately, if we compose two or more meta-models, the result is another standalone meta-model. So, if we have an entity ==JavaMethod== from a Java meta-model that has a relation to ==JavaMethodNode== from a Java AST meta-model, then this relation named  ==#ast== in the method entity must be described somehow and needs to be part of the both meta-models. The ==JavaMethodNode== and related entities need to be known to Java metamodel, they need to be part of it.

The Famix has tools how to compose several meta-model descriptions into one using the meta-model builder definition imports, however, this approach is not very practical because this way we really need to create the third stand-alone meta-model next to both meta-model, from which it is composed. That means another set of classes, new packages etc.

But that does not mean that we cannot compose meta-models. We just need to do it without the explicit connection on the meta-level. In practice, we do the following procedure:

- create the two completely stand-alone meta-models in different packages
- create a new package for the meta-models binding. This package will mostly contain only extension methods to the classes that describe entities in the original meta-models
- for every relation that binds the two meta-models, create methods that describe relation sides without specifying of the real type. Define them as properties that can hold general objects
- use ==privateState== for storing of the data

Let's use our example of ==JavaMethod== and ==JavaMethodNode== that describes the method on AST level. In the method, we want to create a property named ==ast== that will keep the method node. The method node will store information about the method in a property named =owningMethod=

We want to keep the packages with Java and AST meta-models untouched so we will not store information about this relation using slots. Instead of it, we will use the ==privateState== dictionary that every Moose element has.  All the following methods should be added to a separate package with name like ==JavaASTMetamodelsBinding==. This relation is one to one.

Firstly we will create a method named #ast in the method entity. This method will hold the description that this property can be any object.

[[[­lan­gua­ge=­Sma­lltalk
JavaMethod>>#ast 

    <MSEProperty: #ast type: #Object > 
    ^ self privateState 
            attributeAt: #ast
            ifAbsent: []
]]]

We will do the very similar method in ==JavaMethodNode== that will describe the property ==owningMethod==.

[[[­lan­gua­ge=­Sma­lltalk
JavaMethodNode>>#owningMethod

    <MSEProperty: #owningMethod type: #Object> <subordinate>
    ^ self privateState 
            attributeAt: #owningMethod
            ifAbsent: []
]]]

@@note This property is described as subordinate. That means that during export the information about this relation will be stored only on the opposite side of the relation.
 
The corresponding setter to the previous accessor will set the property in the private state and update the opposite side. 

[[[­lan­gua­ge=­Sma­lltalk
JavaMethodNode>>#owningMethod: anObject

    self privateState 
            attributeAt: #owningMethod
            put: anObject.

    anObject ast: self.
]]]

The setter ==ast:== will do the similar task but it needs to have a condition that will avoid the infinite loop.

[[[­lan­gua­ge=­Sma­lltalk
JavaMethod>>ast: anObject

    (self privateState attributeAt: #ast ifAbsent: [nil]) == anObject ifTrue: [ ^ anObject ].
    self privateState attributeAt: #ast put: anObject.
            
    anObject owningMethod: self.
]]]

In case that we describe the relation one to many or many to one, we can use ==FMMultivalueLink== for keeping the relation automatically updated.

When we will create models that will work with both of the meta-models and the binding we created, we need to specify it during the model creation:

[[[language=Smalltalk
    model := MooseModel new.
    
    model metamodel: (MooseModel metamodelComposedOf: { 
        JavaMetamodelGenerator metamodel.
        JavaASTMetamodelGenerator metamodel.
    }).
]]]

We will need to use the meta-model during the MSE export:

[[[language=Smalltalk
    'mixed.mse' asFileReference ensureDelete writeStreamDo: [ :aStream |
        MooseModel export: model withMetamodel: model metamodel to: aStream.
    ].
]]]

During the import of the MSE we need to specify the meta-models too. 

[[[language=Smalltalk
repo := 'mixed.mse' asFileReference readStreamDo: [ :aStream |
    MooseModel importFrom: aStream withMetamodel: (MooseModel metamodelComposedOf: { 
        JavaMetamodelGenerator metamodel.
        JavaASTMetamodelGenerator metamodel.
    })
].

model := MooseModel new.
model silentlyAddAll: repo elements.
model entityStorage forRuntime.
model name: 'Mixed'.
model.
]]]


