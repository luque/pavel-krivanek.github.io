<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">  	
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
  	<meta name="theme" content="hugo-academic">
    <meta name="theme-color" content="primary">
	<title></title>

    <!-- Highlight js -->
    <link rel="stylesheet" href="_support/html/highlightjs/styles/default.css">
    <link rel="stylesheet" href="_support/html/css/highlight-commands.css">
    <script src="_support/html/highlightjs/highlight.pack.js"></script>
    <script src="_support/html/js/highlight-commands.js"></script>

    <!-- Bootstrap -->
    <link href="_support/html/css/bootstrap.min.css" rel="stylesheet">
    <link href="_support/html/css/bootstrap-theme.min.css" rel="stylesheet">
    <link href="_support/html/css/square-braket-associates.css" rel="stylesheet">


  	<link href="_support/html/css/font-awesome.min.css" rel="stylesheet">
  	<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.css" media="screen">
  	<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.3.1/leaflet.css">
	<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/academicons/1.8.4/css/academicons.min.css">
    <link rel="stylesheet" href="_support/html/css/styles.css">
    <link rel="icon" type="image/png" href="_support/html/img/icon.png">
  	<link rel="apple-touch-icon" type="image/png" href="_support/html/img/icon-192.png">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Montserrat:400,700%7cRoboto:400,400italic,700%7cRoboto+Mono">

    <script>
      window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
      ga('create', '', 'auto');
      ga('require', 'eventTracker');
      ga('require', 'outboundLinkTracker');
      ga('require', 'urlChangeTracker');
      ga('send', 'pageview');
    </script>
    <script async src="//www.google-analytics.com/analytics.js"></script>
	

    <style>
/*        .container { max-width: 55em; } */
    </style>

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
      <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
    <![endif]-->
  </head>
  <body>


	<div class="article-header">
	<span class="article-header-caption">Moose Famix</span>
</div>

	<nav class="navbar navbar-default navbar-fixed-top" id="navbar-main">
  <div class="container">

    <!-- Brand and toggle get grouped for better mobile display -->
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse"
              data-target=".navbar-collapse" aria-expanded="false">
        <span class="sr-only"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="/">
        Moose Famix
      </a>
    </div>

    <!-- Collect the nav links, forms, and other content for toggling -->
    <div class="collapse navbar-collapse">

      <ul class="nav navbar-nav navbar-right">
		
        <li class="nav-item">
          <a href="/index.html#introduction">
            <span>Introduction</span>
          </a>
        </li>
		
        <li class="nav-item">
          <a href="/Catalog.html#catalog">
            <span>Catalog</span>
          </a>
        </li>
		
        <li class="nav-item">
          <a href="/Builder.html#builder">
            <span>Builder</span>
          </a>
        </li>
		
        <li class="nav-item">
          <a href="/MetamodelEntities.html#meta-model entities">
            <span>Meta-model entities</span>
          </a>
        </li>
		
        <li class="nav-item">
          <a href="/Relations.html#relations">
            <span>Relations</span>
          </a>
        </li>
		
        <li class="nav-item">
          <a href="/SimplifiedDefinitions.html#simplified definitions">
            <span>Simplified definitions</span>
          </a>
        </li>
		
        <li class="nav-item">
          <a href="/CodeGenerationManagement.html#code generation">
            <span>Code generation</span>
          </a>
        </li>
		
        <li class="nav-item">
          <a href="/Tutorial.html#tutorial">
            <span>Tutorial</span>
          </a>
        </li>
		
      
      </ul>
      

    </div><!-- /.navbar-collapse -->
  </div><!-- /.container -->
</nav>


<!-- Projects widget -->
<section>
<div class="container">
<div class="row">
  <div class="col-xs-12 col-md-4 section-heading">
	<h1></h1>

    
  </div>
  <div class="col-xs-12 col-md-8">

	
<h1>Introduction</h1>

<h2>Moose</h2>

<p>
Moose is a powerful open source platform for software and data analysis. It offers multiple services ranging from importing and parsing data, modeling, measuring, querying and mining of information. It has great support for the creation of interactive and visual analysis tools. 
</p>
<p>
For more information about Moose see <a href="http://www.moosetechnology.org">http://www.moosetechnology.org</a>.
</p>
<h2>Famix</h2>

<p>
Famix is a basic meta-modeling framework for Moose. It provides building blocks from which you can build own custom meta-model that fits your  particular needs while you still can benefit from the advantages that Moose offers.
</p>
<h3>Historical perspective</h3>

<p>
In Moose preceding the versions 7, the FAMIX was a single meta-model that tried to cover the most common properties of all standard languages. This approach has several obvious advantages. With a single meta-model for all languages, you can easily do a software analysis on projects written in them and easily cover very common cases when you have a single project that uses multiple languages at once. The meta-model that provides descriptions of language elements like functions, classes or variables simply uniforms everything into a single frame.
</p>
<p>
This approach where only one meta-model is used has the single but very important disadvantage: it does not work generally. The FAMIX meta-model described well languages like Java, C#, C, C++ and Smalltalk. However, even in the case of these languages, the description was rough and haven't covered all details it could. For example, in the case of Smalltalk, the FAMIX was not describing entities like slots, traits, shared pools and so on. When you analyzed a model in this language, such details were hidden and slots had to be described only with the concept of instance variables. It was possible to investigate the name of slots, browser their users or computer metrics related to them but by default, FAMIX had no default way of modeling other slot properties like their definition. 
</p>
<p>
The Pharo as one particular Smalltalk implementation slightly changed the language metamodel in version 7 by an introduction of stateful traits. It was not possible to cover it with the FAMIX meta-model. It was impossible to describe languages like SQL, various types of domain specific languages nor data without significant ad-hoc extensions to the FAMIX meta-model. 
</p>
<p>
The need for meta-model unification lead sometimes to bizarre design decisions that had no sense in particular languages. For example, the methods were owned by general type, not by classes that are only a kind of types. The inheritance was described on the level of types too so then it was possible to theoretically have a Java model that has a primitive type <code>int</code> with several methods and inherits from <code>float</code>. For FAMIX it was still a valid model.  
</p>
<p class="note">The basic meta-model for Moose prior versions 7 was named FAMIX (all characters were uppercase). The name for the new generation of the meta-model based on groups of traits is named simply Famix.</p>
<p>
While FAMIX tried to unify the meta-models for various languages, it had to unite the most common concepts. Let's take a look at a simplified fragment of Java meta-model (figure <a href="#JavaHierarchy"></a>).
</p>
<p>
<a id="JavaHierarchy"></a>
<figure>
	<img src="Chapters/Introduction/figures/hierarchy-java.svg" width="45%" id="JavaHierarchy" alt="Java and C meta-model fragments"/>
	<figcaption>Java and C meta-model fragments</figcaption>
</figure>
</p>
<p>
Java meta-model needs to describe methods and classes. Both of the meta-model elements share some behavior (e.g. they can have a link to source) so they inherit from common superclass <code>JavaEntity</code>. The C language does not have classes or methods. On the other hand, it needs to describe the concept of functions that is not used in Java.
</p>
<p>
The C++ has classes and it the programs can use methods and functions together. Functions and methods are to some extent similar behavioural entities so it makes sense to introduce a common generalization for them.  
</p>
<p>
<a id="CppHierarchy"></a>
<figure>
	<img src="Chapters/Introduction/figures/hierarchy-cpp.svg" width="40%" id="CppHierarchy" alt="C++ meta-model fragment"/>
	<figcaption>C++ meta-model fragment</figcaption>
</figure>
</p>
<p>
While FAMIX tried to uniform all these languages, its metamodel followed the structure of the C++ metamodel. So when a user analyzed a C program using Moose, the tools provided a lot of data like metrics for classes that had not any sense in the context of the C program.
</p>
<h3>Standalone meta-models</h3>

<p>
The Famix in Moose version 7 was significantly changed. Now the Famix is not one unifying meta-model that tries to cover everything, but it is a set of building blocks, small fragments of the meta-models. A user creates own meta-models of these fragments and can easily add custom elements that cannot be described by anything that Famix provides by default. That is especially important for modelling of custom domain-specific languages or structured data.
</p>
<p>
Now every modeled language has its own standalone meta-model. Particular meta-models do not share entities, so every language has custom classes even for the very general meta-model entities like named entities (was <code>FAMIXNamedEntity</code>). Now we need <code>JavaNamedEntity</code>, <code>CNamedEntity</code>, <code>SmalltalkNamedEntity</code> and so on.
</p>
<h3>Trait groups</h3>

<p>
The fundamental component of the Famix is a <strong>trait group</strong>. A trait group always describes a fragment of meta-model and can consist of one, two or more entities and relations between them.
</p>
<p>
We can demonstrate it on an example of the <em>access</em>. In some meta-model, we have two kinds of entities: local variables and methods. Methods contain a code that reads some local variables or writes data to them. Let's have a program that contains a method named <code>aMethod</code> with a local variable named <code>foo</code>. It writes data to it and then uses it in a method call.
</p>
<figure><pre><code>    public void aMethod() {
        int foo = 5;
        someMethod(foo);
    }</code></pre><figcaption></figcaption></figure>

<p>
Now we will try to model our little program using the meta-model. We will create an object for the method <code>aMethod</code>, an object that models the variable <code>foo</code> that contains information, wherein the code the instance variable was declared. But one crucial information is missing. We would like where in the code the variable was accessed and what kind of access was that. Was the variable written or read? With such information, we can do a straightforward but useful analysis of the program models and decide, what local variables were not used or just written and never read.
</p>
<p>
To model the association between the variable and method, we will introduce a new kind of entity in our metamodel: the access. For every access to a local variable, we will create an object that describes is. It will contain information what the accessed local variable was, what method accessed it, wherein the code this concrete access is placed and what kind of access is it (read or write). 
</p>
<p>
The Famix provides a meta-model fragment exactly for this use-case. It contains a trait group named <em>Access</em> that describes three entities: access itself (<code>Access</code>), the element that is being accessed (<code>Accessible</code>, in our case, it is the local variable) and an entity that contains accesses (<code>WithAccesses</code>, in case of our meta-model it is the method). 
</p>
<p>
<a id="fig:accessGroup"></a>
<figure>
	<img src="Chapters/Introduction/figures/accessGroup.svg" width="45%" id="fig:accessGroup" alt="Access trait group"/>
	<figcaption>Access trait group</figcaption>
</figure>
</p>
<p>
This trait group describes relations between these three entities. So <code>WithAccesses</code> has accesses, <code>Accessible</code> has incomming accesses, and the <code>Access</code> stores information aoubt its  accessor and variable.
</p>
<p>
The entities that Famix provides are not real meta-model entities. They cannot be instantiated directly. They are provided in form of <em>traits</em>. That means that you need to apply them on your custom meta-model. That's why in following text they will have a prefix <code>T</code> (meaning <em>trait</em>).
</p>
<p>
The concrete language meta-model will contain three real entities: <code>JavaLocalVariable</code>, <code>JavaMethod</code> and <code>JavaAccess</code>. What we will do is to apply the traits provided by the Famix trait group on them. So <code>JavaAccess</code> will use the trait <code>TAccess</code>, <code>JavaMethod</code> will use the trait <code>TWithAccesses</code> and 
</p>
<p>
<a id="fig:accessTraits"></a>
<figure>
	<img src="Chapters/Introduction/figures/accessTraits.svg" width="65%" id="fig:accessTraits" alt="Famix traits applied on real meta-model entities"/>
	<figcaption>Famix traits applied on real meta-model entities</figcaption>
</figure>
</p>
<p class="note">In reality, the traits names include prefíx <code>FamixT</code> so the real trait names are <code>FamixTAccess</code>, <code>FamixTAccessible</code> and <code>FamixTWithAccesses</code>.</p>
<p>
The entities and relations that trait groups describe tend to be as general as possible. We can use it for the description of accesses to other kinds of variables like instance variables or global ones.   We can use the same group in the C meta-model for the description of functions to variables. 
</p>
<p>
To use these traits in our meta-model is the only operation we need. When we do that, they automatically extend capabilities of our meta-model so the entities of a model will provide relevant related information in the inspectors and so on.
</p>
<p>
The particular meta-model entities are not limited on only class group, they can use traits from various Famix trait gropus so you can easily compose a custom meta-model with a non-trivial functionality with minimum of effort. 
</p>
<p class="note">Remember: Famix trait groups are concept that allows reuseability of meta-model fragments and easy composition of custom meta-models.</p>
<h3>Famix meta-model builder</h3>

<p>
To make the composition of meta-models easier, Moose provides a builder. The builder uses custom Smalltalk-based domain specific language for meta-models description so when you create a custom meta-model, you describe it using this DSL and the Smalltalk classes of the meta-model will be automatically generated or updated. 
</p>
<p>
More in the chapter <a href="">Builder</a>
</p>



<p>
<h1>Catalog</h1>
<a id="ch:ngCatalog"></a>
<h3>Access</h3>

<p>
<a id="fig:Access"></a>
<figure>
	<img src="Chapters/Introduction/figures/Access.svg" width="50%" id="fig:Access" alt="Access"/>
	<figcaption>Access</figcaption>
</figure>
</p>
<p>
TODO: This trait group requires description, see <a href="#fig:Access"></a>
</p>


<h3>AnnotationInstance</h3>

<p>
<a id="fig:AnnotationInstance"></a>
<figure>
	<img src="Chapters/Introduction/figures/AnnotationInstance.svg" width="36%" id="fig:AnnotationInstance" alt="AnnotationInstance"/>
	<figcaption>AnnotationInstance</figcaption>
</figure>
</p>
<p>
TODO: This trait group requires description, see <a href="#fig:AnnotationInstance"></a>
</p>


<h3>AnnotationInstanceAttribute</h3>

<p>
<a id="fig:AnnotationInstanceAttribute"></a>
<figure>
	<img src="Chapters/Introduction/figures/AnnotationInstanceAttribute.svg" width="43%" id="fig:AnnotationInstanceAttribute" alt="AnnotationInstanceAttribute"/>
	<figcaption>AnnotationInstanceAttribute</figcaption>
</figure>
</p>
<p>
TODO: This trait group requires description, see <a href="#fig:AnnotationInstanceAttribute"></a>
</p>


<h3>AnnotationType</h3>

<p>
<a id="fig:AnnotationType"></a>
<figure>
	<img src="Chapters/Introduction/figures/AnnotationType.svg" width="59%" id="fig:AnnotationType" alt="AnnotationType"/>
	<figcaption>AnnotationType</figcaption>
</figure>
</p>
<p>
TODO: This trait group requires description, see <a href="#fig:AnnotationType"></a>
</p>


<h3>AnnotationTypeAttribute</h3>

<p>
<a id="fig:AnnotationTypeAttribute"></a>
<figure>
	<img src="Chapters/Introduction/figures/AnnotationTypeAttribute.svg" width="48%" id="fig:AnnotationTypeAttribute" alt="AnnotationTypeAttribute"/>
	<figcaption>AnnotationTypeAttribute</figcaption>
</figure>
</p>
<p>
TODO: This trait group requires description, see <a href="#fig:AnnotationTypeAttribute"></a>
</p>


<h3>Association</h3>

<p>
<a id="fig:Association"></a>
<figure>
	<img src="Chapters/Introduction/figures/Association.svg" width="25%" id="fig:Association" alt="Association"/>
	<figcaption>Association</figcaption>
</figure>
</p>
<p>
TODO: This trait group requires description, see <a href="#fig:Association"></a>
</p>


<h3>Attribute</h3>

<p>
<a id="fig:Attribute"></a>
<figure>
	<img src="Chapters/Introduction/figures/Attribute.svg" width="24%" id="fig:Attribute" alt="Attribute"/>
	<figcaption>Attribute</figcaption>
</figure>
</p>
<p>
TODO: This trait group requires description, see <a href="#fig:Attribute"></a>
</p>


<h3>CaughtException</h3>

<p>
<a id="fig:CaughtException"></a>
<figure>
	<img src="Chapters/Introduction/figures/CaughtException.svg" width="30%" id="fig:CaughtException" alt="CaughtException"/>
	<figcaption>CaughtException</figcaption>
</figure>
</p>
<p>
TODO: This trait group requires description, see <a href="#fig:CaughtException"></a>
</p>


<h3>Class</h3>

<p>
<a id="fig:Class"></a>
<figure>
	<img src="Chapters/Introduction/figures/Class.svg" width="11%" id="fig:Class" alt="Class"/>
	<figcaption>Class</figcaption>
</figure>
</p>
<p>
TODO: This trait group requires description, see <a href="#fig:Class"></a>
</p>


<h3>ClassHierarchyNavigation</h3>

<p>
<a id="fig:ClassHierarchyNavigation"></a>
<figure>
	<img src="Chapters/Introduction/figures/ClassHierarchyNavigation.svg" width="28%" id="fig:ClassHierarchyNavigation" alt="ClassHierarchyNavigation"/>
	<figcaption>ClassHierarchyNavigation</figcaption>
</figure>
</p>
<p>
TODO: This trait group requires description, see <a href="#fig:ClassHierarchyNavigation"></a>
</p>


<h3>ClassMetrics</h3>

<p>
<a id="fig:ClassMetrics"></a>
<figure>
	<img src="Chapters/Introduction/figures/ClassMetrics.svg" width="39%" id="fig:ClassMetrics" alt="ClassMetrics"/>
	<figcaption>ClassMetrics</figcaption>
</figure>
</p>
<p>
TODO: This trait group requires description, see <a href="#fig:ClassMetrics"></a>
</p>


<h3>Comment</h3>

<p>
<a id="fig:Comment"></a>
<figure>
	<img src="Chapters/Introduction/figures/Comment.svg" width="25%" id="fig:Comment" alt="Comment"/>
	<figcaption>Comment</figcaption>
</figure>
</p>
<p>
TODO: This trait group requires description, see <a href="#fig:Comment"></a>
</p>


<h3>CompilationUnit</h3>

<p>
<a id="fig:CompilationUnit"></a>
<figure>
	<img src="Chapters/Introduction/figures/CompilationUnit.svg" width="34%" id="fig:CompilationUnit" alt="CompilationUnit"/>
	<figcaption>CompilationUnit</figcaption>
</figure>
</p>
<p>
TODO: This trait group requires description, see <a href="#fig:CompilationUnit"></a>
</p>


<h3>DeclaredException</h3>

<p>
<a id="fig:DeclaredException"></a>
<figure>
	<img src="Chapters/Introduction/figures/DeclaredException.svg" width="35%" id="fig:DeclaredException" alt="DeclaredException"/>
	<figcaption>DeclaredException</figcaption>
</figure>
</p>
<p>
TODO: This trait group requires description, see <a href="#fig:DeclaredException"></a>
</p>


<h3>DereferencedInvocation</h3>

<p>
<a id="fig:DereferencedInvocation"></a>
<figure>
	<img src="Chapters/Introduction/figures/DereferencedInvocation.svg" width="42%" id="fig:DereferencedInvocation" alt="DereferencedInvocation"/>
	<figcaption>DereferencedInvocation</figcaption>
</figure>
</p>
<p>
TODO: This trait group requires description, see <a href="#fig:DereferencedInvocation"></a>
</p>


<h3>EnumValue</h3>

<p>
<a id="fig:EnumValue"></a>
<figure>
	<img src="Chapters/Introduction/figures/EnumValue.svg" width="24%" id="fig:EnumValue" alt="EnumValue"/>
	<figcaption>EnumValue</figcaption>
</figure>
</p>
<p>
TODO: This trait group requires description, see <a href="#fig:EnumValue"></a>
</p>


<h3>Exception</h3>

<p>
<a id="fig:Exception"></a>
<figure>
	<img src="Chapters/Introduction/figures/Exception.svg" width="26%" id="fig:Exception" alt="Exception"/>
	<figcaption>Exception</figcaption>
</figure>
</p>
<p>
TODO: This trait group requires description, see <a href="#fig:Exception"></a>
</p>


<h3>File</h3>

<p>
<a id="fig:File"></a>
<figure>
	<img src="Chapters/Introduction/figures/File.svg" width="23%" id="fig:File" alt="File"/>
	<figcaption>File</figcaption>
</figure>
</p>
<p>
TODO: This trait group requires description, see <a href="#fig:File"></a>
</p>


<h3>FileAnchor</h3>

<p>
<a id="fig:FileAnchor"></a>
<figure>
	<img src="Chapters/Introduction/figures/FileAnchor.svg" width="19%" id="fig:FileAnchor" alt="FileAnchor"/>
	<figcaption>FileAnchor</figcaption>
</figure>
</p>
<p>
TODO: This trait group requires description, see <a href="#fig:FileAnchor"></a>
</p>


<h3>FileInclude</h3>

<p>
<a id="fig:FileInclude"></a>
<figure>
	<img src="Chapters/Introduction/figures/FileInclude.svg" width="56%" id="fig:FileInclude" alt="FileInclude"/>
	<figcaption>FileInclude</figcaption>
</figure>
</p>
<p>
TODO: This trait group requires description, see <a href="#fig:FileInclude"></a>
</p>


<h3>Folder</h3>

<p>
<a id="fig:Folder"></a>
<figure>
	<img src="Chapters/Introduction/figures/Folder.svg" width="37%" id="fig:Folder" alt="Folder"/>
	<figcaption>Folder</figcaption>
</figure>
</p>
<p>
TODO: This trait group requires description, see <a href="#fig:Folder"></a>
</p>


<h3>Function</h3>

<p>
<a id="fig:Function"></a>
<figure>
	<img src="Chapters/Introduction/figures/Function.svg" width="22%" id="fig:Function" alt="Function"/>
	<figcaption>Function</figcaption>
</figure>
</p>
<p>
TODO: This trait group requires description, see <a href="#fig:Function"></a>
</p>


<h3>GlobalVariable</h3>

<p>
<a id="fig:GlobalVariable"></a>
<figure>
	<img src="Chapters/Introduction/figures/GlobalVariable.svg" width="27%" id="fig:GlobalVariable" alt="GlobalVariable"/>
	<figcaption>GlobalVariable</figcaption>
</figure>
</p>
<p>
TODO: This trait group requires description, see <a href="#fig:GlobalVariable"></a>
</p>


<h3>Header</h3>

<p>
<a id="fig:Header"></a>
<figure>
	<img src="Chapters/Introduction/figures/Header.svg" width="20%" id="fig:Header" alt="Header"/>
	<figcaption>Header</figcaption>
</figure>
</p>
<p>
TODO: This trait group requires description, see <a href="#fig:Header"></a>
</p>


<h3>ImplicitVariable</h3>

<p>
<a id="fig:ImplicitVariable"></a>
<figure>
	<img src="Chapters/Introduction/figures/ImplicitVariable.svg" width="34%" id="fig:ImplicitVariable" alt="ImplicitVariable"/>
	<figcaption>ImplicitVariable</figcaption>
</figure>
</p>
<p>
TODO: This trait group requires description, see <a href="#fig:ImplicitVariable"></a>
</p>


<h3>Invocable</h3>

<p>
<a id="fig:Invocable"></a>
<figure>
	<img src="Chapters/Introduction/figures/Invocable.svg" width="63%" id="fig:Invocable" alt="Invocable"/>
	<figcaption>Invocable</figcaption>
</figure>
</p>
<p>
TODO: This trait group requires description, see <a href="#fig:Invocable"></a>
</p>


<h3>LCOMMetrics</h3>

<p>
<a id="fig:LCOMMetrics"></a>
<figure>
	<img src="Chapters/Introduction/figures/LCOMMetrics.svg" width="17%" id="fig:LCOMMetrics" alt="LCOMMetrics"/>
	<figcaption>LCOMMetrics</figcaption>
</figure>
</p>
<p>
TODO: This trait group requires description, see <a href="#fig:LCOMMetrics"></a>
</p>


<h3>LocalVariable</h3>

<p>
<a id="fig:LocalVariable"></a>
<figure>
	<img src="Chapters/Introduction/figures/LocalVariable.svg" width="33%" id="fig:LocalVariable" alt="LocalVariable"/>
	<figcaption>LocalVariable</figcaption>
</figure>
</p>
<p>
TODO: This trait group requires description, see <a href="#fig:LocalVariable"></a>
</p>


<h3>Method</h3>

<p>
<a id="fig:Method"></a>
<figure>
	<img src="Chapters/Introduction/figures/Method.svg" width="23%" id="fig:Method" alt="Method"/>
	<figcaption>Method</figcaption>
</figure>
</p>
<p>
TODO: This trait group requires description, see <a href="#fig:Method"></a>
</p>


<h3>Module</h3>

<p>
<a id="fig:Module"></a>
<figure>
	<img src="Chapters/Introduction/figures/Module.svg" width="26%" id="fig:Module" alt="Module"/>
	<figcaption>Module</figcaption>
</figure>
</p>
<p>
TODO: This trait group requires description, see <a href="#fig:Module"></a>
</p>


<h3>Named</h3>

<p>
<a id="fig:Named"></a>
<figure>
	<img src="Chapters/Introduction/figures/Named.svg" width="16%" id="fig:Named" alt="Named"/>
	<figcaption>Named</figcaption>
</figure>
</p>
<p>
TODO: This trait group requires description, see <a href="#fig:Named"></a>
</p>


<h3>Namespace</h3>

<p>
<a id="fig:Namespace"></a>
<figure>
	<img src="Chapters/Introduction/figures/Namespace.svg" width="49%" id="fig:Namespace" alt="Namespace"/>
	<figcaption>Namespace</figcaption>
</figure>
</p>
<p>
TODO: This trait group requires description, see <a href="#fig:Namespace"></a>
</p>


<h3>Package</h3>

<p>
<a id="fig:Package"></a>
<figure>
	<img src="Chapters/Introduction/figures/Package.svg" width="25%" id="fig:Package" alt="Package"/>
	<figcaption>Package</figcaption>
</figure>
</p>
<p>
TODO: This trait group requires description, see <a href="#fig:Package"></a>
</p>


<h3>Parameter</h3>

<p>
<a id="fig:Parameter"></a>
<figure>
	<img src="Chapters/Introduction/figures/Parameter.svg" width="36%" id="fig:Parameter" alt="Parameter"/>
	<figcaption>Parameter</figcaption>
</figure>
</p>
<p>
TODO: This trait group requires description, see <a href="#fig:Parameter"></a>
</p>


<h3>ParameterizedType</h3>

<p>
<a id="fig:ParameterizedType"></a>
<figure>
	<img src="Chapters/Introduction/figures/ParameterizedType.svg" width="36%" id="fig:ParameterizedType" alt="ParameterizedType"/>
	<figcaption>ParameterizedType</figcaption>
</figure>
</p>
<p>
TODO: This trait group requires description, see <a href="#fig:ParameterizedType"></a>
</p>


<h3>ParameterizedTypeUser</h3>

<p>
<a id="fig:ParameterizedTypeUser"></a>
<figure>
	<img src="Chapters/Introduction/figures/ParameterizedTypeUser.svg" width="47%" id="fig:ParameterizedTypeUser" alt="ParameterizedTypeUser"/>
	<figcaption>ParameterizedTypeUser</figcaption>
</figure>
</p>
<p>
TODO: This trait group requires description, see <a href="#fig:ParameterizedTypeUser"></a>
</p>


<h3>PossibleStub</h3>

<p>
<a id="fig:PossibleStub"></a>
<figure>
	<img src="Chapters/Introduction/figures/PossibleStub.svg" width="17%" id="fig:PossibleStub" alt="PossibleStub"/>
	<figcaption>PossibleStub</figcaption>
</figure>
</p>
<p>
TODO: This trait group requires description, see <a href="#fig:PossibleStub"></a>
</p>


<h3>PreprocessorDefine</h3>

<p>
<a id="fig:PreprocessorDefine"></a>
<figure>
	<img src="Chapters/Introduction/figures/PreprocessorDefine.svg" width="23%" id="fig:PreprocessorDefine" alt="PreprocessorDefine"/>
	<figcaption>PreprocessorDefine</figcaption>
</figure>
</p>
<p>
TODO: This trait group requires description, see <a href="#fig:PreprocessorDefine"></a>
</p>


<h3>PreprocessorIfdef</h3>

<p>
<a id="fig:PreprocessorIfdef"></a>
<figure>
	<img src="Chapters/Introduction/figures/PreprocessorIfdef.svg" width="21%" id="fig:PreprocessorIfdef" alt="PreprocessorIfdef"/>
	<figcaption>PreprocessorIfdef</figcaption>
</figure>
</p>
<p>
TODO: This trait group requires description, see <a href="#fig:PreprocessorIfdef"></a>
</p>


<h3>Reference</h3>

<p>
<a id="fig:Reference"></a>
<figure>
	<img src="Chapters/Introduction/figures/Reference.svg" width="50%" id="fig:Reference" alt="Reference"/>
	<figcaption>Reference</figcaption>
</figure>
</p>
<p>
TODO: This trait group requires description, see <a href="#fig:Reference"></a>
</p>


<h3>ScopingEntity</h3>

<p>
<a id="fig:ScopingEntity"></a>
<figure>
	<img src="Chapters/Introduction/figures/ScopingEntity.svg" width="31%" id="fig:ScopingEntity" alt="ScopingEntity"/>
	<figcaption>ScopingEntity</figcaption>
</figure>
</p>
<p>
TODO: This trait group requires description, see <a href="#fig:ScopingEntity"></a>
</p>


<h3>SourceAnchor</h3>

<p>
<a id="fig:SourceAnchor"></a>
<figure>
	<img src="Chapters/Introduction/figures/SourceAnchor.svg" width="46%" id="fig:SourceAnchor" alt="SourceAnchor"/>
	<figcaption>SourceAnchor</figcaption>
</figure>
</p>
<p>
TODO: This trait group requires description, see <a href="#fig:SourceAnchor"></a>
</p>


<h3>SourceLanguage</h3>

<p>
<a id="fig:SourceLanguage"></a>
<figure>
	<img src="Chapters/Introduction/figures/SourceLanguage.svg" width="35%" id="fig:SourceLanguage" alt="SourceLanguage"/>
	<figcaption>SourceLanguage</figcaption>
</figure>
</p>
<p>
TODO: This trait group requires description, see <a href="#fig:SourceLanguage"></a>
</p>


<h3>Sub</h3>

<p>
<a id="fig:Sub"></a>
<figure>
	<img src="Chapters/Introduction/figures/Sub.svg" width="14%" id="fig:Sub" alt="Sub"/>
	<figcaption>Sub</figcaption>
</figure>
</p>
<p>
TODO: This trait group requires description, see <a href="#fig:Sub"></a>
</p>


<h3>SubInheritance</h3>

<p>
<a id="fig:SubInheritance"></a>
<figure>
	<img src="Chapters/Introduction/figures/SubInheritance.svg" width="30%" id="fig:SubInheritance" alt="SubInheritance"/>
	<figcaption>SubInheritance</figcaption>
</figure>
</p>
<p>
TODO: This trait group requires description, see <a href="#fig:SubInheritance"></a>
</p>


<h3>SuperInheritance</h3>

<p>
<a id="fig:SuperInheritance"></a>
<figure>
	<img src="Chapters/Introduction/figures/SuperInheritance.svg" width="29%" id="fig:SuperInheritance" alt="SuperInheritance"/>
	<figcaption>SuperInheritance</figcaption>
</figure>
</p>
<p>
TODO: This trait group requires description, see <a href="#fig:SuperInheritance"></a>
</p>


<h3>Template</h3>

<p>
<a id="fig:Template"></a>
<figure>
	<img src="Chapters/Introduction/figures/Template.svg" width="45%" id="fig:Template" alt="Template"/>
	<figcaption>Template</figcaption>
</figure>
</p>
<p>
TODO: This trait group requires description, see <a href="#fig:Template"></a>
</p>


<h3>ThrownException</h3>

<p>
<a id="fig:ThrownException"></a>
<figure>
	<img src="Chapters/Introduction/figures/ThrownException.svg" width="32%" id="fig:ThrownException" alt="ThrownException"/>
	<figcaption>ThrownException</figcaption>
</figure>
</p>
<p>
TODO: This trait group requires description, see <a href="#fig:ThrownException"></a>
</p>


<h3>Type</h3>

<p>
<a id="fig:Type"></a>
<figure>
	<img src="Chapters/Introduction/figures/Type.svg" width="63%" id="fig:Type" alt="Type"/>
	<figcaption>Type</figcaption>
</figure>
</p>
<p>
TODO: This trait group requires description, see <a href="#fig:Type"></a>
</p>


<h3>TypeAlias</h3>

<p>
<a id="fig:TypeAlias"></a>
<figure>
	<img src="Chapters/Introduction/figures/TypeAlias.svg" width="24%" id="fig:TypeAlias" alt="TypeAlias"/>
	<figcaption>TypeAlias</figcaption>
</figure>
</p>
<p>
TODO: This trait group requires description, see <a href="#fig:TypeAlias"></a>
</p>


<h3>TypedStructure</h3>

<p>
<a id="fig:TypedStructure"></a>
<figure>
	<img src="Chapters/Introduction/figures/TypedStructure.svg" width="39%" id="fig:TypedStructure" alt="TypedStructure"/>
	<figcaption>TypedStructure</figcaption>
</figure>
</p>
<p>
TODO: This trait group requires description, see <a href="#fig:TypedStructure"></a>
</p>


<h3>WithClassScope</h3>

<p>
<a id="fig:WithClassScope"></a>
<figure>
	<img src="Chapters/Introduction/figures/WithClassScope.svg" width="20%" id="fig:WithClassScope" alt="WithClassScope"/>
	<figcaption>WithClassScope</figcaption>
</figure>
</p>
<p>
TODO: This trait group requires description, see <a href="#fig:WithClassScope"></a>
</p>


<h3>WithModifiers</h3>

<p>
<a id="fig:WithModifiers"></a>
<figure>
	<img src="Chapters/Introduction/figures/WithModifiers.svg" width="17%" id="fig:WithModifiers" alt="WithModifiers"/>
	<figcaption>WithModifiers</figcaption>
</figure>
</p>
<p>
TODO: This trait group requires description, see <a href="#fig:WithModifiers"></a>
</p>


<h3>WithSignature</h3>

<p>
<a id="fig:WithSignature"></a>
<figure>
	<img src="Chapters/Introduction/figures/WithSignature.svg" width="18%" id="fig:WithSignature" alt="WithSignature"/>
	<figcaption>WithSignature</figcaption>
</figure>
</p>
<p>
TODO: This trait group requires description, see <a href="#fig:WithSignature"></a>
</p>



<h1>Builder</h1>
<a id="ch:Builder"></a>
<h2>Creation of a builder</h2>
<a id="ch:creationOfABuilder"></a>
<p>
The primary class of the metamodel builder is named <code>FamixMetamodelBuilder</code>. There are several ways how instances of this class can be created. 
</p>
<h3>Builder for real environment</h3>

<p>
If builders are created using the standard <code>new</code> message sent to the <code>FamixMetamodelBuilder</code> class, builder will work on real environment (implemented in class FamixMetamodelBuilderRealEnvironment). That means that all classes generated by the builder will be installed directly to the Pharo image and models can be instantiated from them.
</p>
<figure><pre><code>builder := FamixMetamodelBuilder new.</code></pre><figcaption></figcaption></figure>

<h3>Builder for testing environment</h3>

<p>
The other option is to create a builder that is bound to a <em>Ring</em> environment, and all generated classes a part of this environment. It is used mainly for testing purposes because it does not modify any classes in the system, it is faster and the tests do not need to do a difficult cleanup. Such generated <em>Ring</em> environments can be used for other purposes like the direct export of the generated package too. 
</p>
<p>
On the other hand, it is not possible to instantiate such generated classes so no real model can be created from them.
</p>
<figure><pre><code>builder := FamixMetamodelBuilder forTesting.</code></pre><figcaption></figcaption></figure>

<h3>Code generation</h3>

<p>
The code is generated using the message <code>generate</code> sent to the builder. If no element of the meta-model is created then it will not do anything useful. 
</p>
<figure><pre><code>builder := FamixMetamodelBuilder new.
builder generate.</code></pre><figcaption></figcaption></figure>

<p>
Although the builder instances can be used directly in a method or in a script that generates your meta-model, in most cases the builder is created as an instance variable of a subclass <code>FamixMetamodelGenerator</code> because then the meta-model definition can be split into several methods or classes (see chapter <a href="#ch:codeGenerationManagement"></a>).
</p>


<h3>Builder settings</h3>
<a id="ch:builderSettings"></a>
<p>
We need to specify into which package the generated classes will be placed. It can be done using the message <code>packageName:</code> sent to a builder. If not set, a default value (<code>FamixMetamodelBulder-Generated</code>) will be used.
</p>
<p>
Then we should specify a class name prefix. It is a prefix that will be added before the name of every generated class. 
</p>
<figure><pre><code>builder 
    prefix: 'SQLMeta';
    packageName: 'SQL-Metamodel'.</code></pre><figcaption></figcaption></figure>

<p>
In the definition of the meta-model, the class names are used without a prefix which makes orientation in the code of the meta-model easier. However, the name of real classes includes the specified prefix. Keep that in mind when you use such classes from a non-generated code.
</p>
<p>
The default prefix is empty.
 
</p><h3>Class tags</h3>

<p>
By default, the classes a generated with a tag <em>Entities</em> so in our case, the classes are placed in a category named <em>SQL-Metamodel-Entities</em>. The traits generated by the builder have a tag 'Traits'. The names of tags for entities and traits can be modified (messages <code>classTag:</code> and <code>traitTag:</code> and it is valid from this point for all the future specified classes. 
</p>
<p>
The tag can be set for classes and traits individually using the message <code>tag:</code>
</p>
<h3>Basic superclasses</h3>

<p>
When a generalization of a class is not specified, a default superclass is used (<code>MooseEntity</code>). When the builder is used for generation of meta-models independent of Moose, or if the builder serves for generation of a meta-model which extends another meta-model, some other class can be selected as a default superclass (message <code>basicSuperclassName:</code>).
</p>
<p>
For stateful traits (that mostly look as standard classes) a default superclass is different. It can be set using the message <code>defaultBasicTraitName:</code> and the default value is <code>Trait</code>. It is not recommended to change it. 
</p>
<p>
Keep in mind that the basic superclasses and traits are expected to provide some behavior (e.g. class slots initialization) so be careful when you change them.

</p>
<h1>Meta-model entities</h1>
<a id="ch:metamodelEntities"></a>
<p>
The basic entities of the meta-models are classes and traits. 
</p>
<h2>Classes</h2>

<p>
For the meta-model generator, classes are entities with shared behavior that can be instantiated. They are used for description of meta-model elements like <em>Package</em>, <em>Method</em>, <em>Class</em>, <em>Table</em> etc. We define them in the builder using a message <code>newClassNamed:</code>.
</p>
<figure><pre><code>builder := FamixMetamodelBuilder new.
function := builder newClassNamed: #Function.
builder generate.</code></pre><figcaption></figcaption></figure>

<p>
They are physically not generated immediately, but they are created together with other defined entities when the builder receives message <code>generate</code>. When the class is defined, the currently valid builder prefix is used for it and stored as a property of the class. Later change of the builder's prefix does not affect the classes that are already defined.
</p>
<h2>Traits</h2>

<p>
Traits are independent units of shared behavior. They are very similar to classes but they cannot be instantiated and they are used differently for generalization. The stateful traits introduced in Pharo 7.0 are used for them. That means that they can hold instance variables (<em>slots</em>) so, from that perspective, they act as standard Pharo classes and they provide most of their power. However, because they usually provide only a small unit of shared behavior, it is handy to place all the meta-model behavior into the traits and let classes to only use them. Then such traits can be easily reused for other meta-models.
</p>
<p>
Their name usually starts with the character <code>T</code> and they are defined in the builder using a message <code>newTraitNamed:</code>.
</p>
<figure><pre><code>tFunction := builder newTraitNamed: #TFunction.</code></pre><figcaption></figcaption></figure>

<h2>Generalization </h2>

<p>
When the entities are defined in a builder, generalization relationships can be set between them using a binary message <code>&lt;|--</code> that tries to look like the standard UML generalization arrow.
</p>
<figure><pre><code>behaviouralEntity := builder newClassNamed: #BehaviouralEntity.
function := builder newClassNamed: #Function.
behaviouralEntity &lt;|-- function.</code></pre><figcaption></figcaption></figure>

<p>
In this case it means that the class <code>Function</code> is a subclass of the class <code>BehaviouralEntity</code>. Alternatively a keyword message <code>subclassOf:</code> can be used with the same result.
</p>
<figure><pre><code>function subclassOf: behaviouralEntity.</code></pre><figcaption></figcaption></figure>

<p>
Because <code>&lt;|--</code> is a standard binary message, it can be used in a chain
</p><figure><pre><code>named &lt;|-- behavior &lt;|-- class</code></pre><figcaption></figcaption></figure>

<p>
Classes can have only one superclass. If no superclass is specified, a default superclass is used. Traits are <em>never</em> generalizations of other entities so they always inherit from the default superclass (<em>baseTrait</em>). Their class hierarchy is flat.
</p>
<h2>Generalization from traits - multiple inheritance</h2>

<p>
The meta-model classes can be the specialization of only one single class, but besides that, they can use none, one, or several traits.
The notation for traits composition is the same as for the class generalization (<code>&lt;|--</code>).
</p>
<figure><pre><code>behavior := builder newClassNamed: #Behavior.    
tBehavior := builder newTraitNamed: #TBehavior.
tBehavior &lt;|-- behavior.</code></pre><figcaption></figcaption></figure>

<p>
This is the way how multiple inheritance can be expressed in the meta-model. Let's have classes <code>A</code>, <code>B</code> and <code>C</code>. We want <code>B</code> to be sublcass of <code>A</code> and <code>C</code>. It cannot be done directly. We need to make a trait <code>TC</code> that provides all the behavior of the class <code>C</code> and then let <code>B</code> and <code>C</code> use this trait.
</p>
<p>
<a id="multipleInheritance1"></a>
<figure>
	<img src="Chapters/MetamodelEntities/figures/multipleInheritance1.svg" width="18%" id="multipleInheritance1" alt="Multiple inheritance with classes"/>
	<figcaption>Multiple inheritance with classes</figcaption>
</figure>
</p>
<p>
<a id="multipleInheritance2"></a>
<figure>
	<img src="Chapters/MetamodelEntities/figures/multipleInheritance2.svg" width="19%" id="multipleInheritance2" alt="Multiple inheritance with classes and traits"/>
	<figcaption>Multiple inheritance with classes and traits</figcaption>
</figure>
</p>
<figure><pre><code>a := builder newClassNamed: #A.    
b := builder newClassNamed: #B.    
c := builder newClassNamed: #C.
tc := builder newTraitNamed: #TC.    
a &lt;|-- b.
tc &lt;|-- c.
tc &lt;|-- b.</code></pre><figcaption></figcaption></figure>

<p>
Of course, creating a class for <code>C</code> is necessary only in a case when the class <code>C</code> needs to be instantiated. In other cases, one need only the trait <code>TC</code>.
</p>
<h2>Simple properties</h2>

<p>
The non-relational properties of meta-model entities are defined using the method <code>name:type:</code> that accepts as the first argument a symbolic name of the property and as the second argument a name of a type. This type can be any class name, but most likely it is a name of a primitive type like <code>String</code>, <code>Number</code>, or <code>Boolean</code>.
</p>
<figure><pre><code>namedEntity property: #name type: #String.</code></pre><figcaption></figcaption></figure>

<p>
Comment of the property can be set.
</p>
<figure><pre><code>(namedEntity property: #name type: #String)
    comment: 'This is a comment'.</code></pre><figcaption></figcaption></figure>

<h1>Relations</h1>
<a id="ch:relations"></a>
<p>
Very often the meta-model entities contain properties that are in some kind of relation. For example, we have an entity for class comments and an entity for classes. Classes have a reference on their class comments, and the class comments have a reference on owning classes. In such cases, we connect such properties into a relation.
</p>
<p>
The main advantage of properties connected with relations lies in their automatic updates. When you assign a comment to a class, the class is automatically assigned to the comment. 
</p>
<p>
Properties that are sides of relations are created with the message <code>property:</code> sent to an entity. This message accepts a property name as an argument. The are two ways how to connect defined properties. One uses keyword messages that describe cardinality of particular relation sides: 
</p>
<figure><pre><code>(tClass property: #comment) oneToOne: (tComment property: #owningClass).</code></pre><figcaption></figcaption></figure>

<p>
The second one uses binary messages that tries to be similar to UML connectors:
</p>
<figure><pre><code>tClass := builder newTraitNamed: #TClass. 
tComment := builder newTraitNamed: #TComment. 
(tClass property: #comment) - (tComment property: #owningClass).</code></pre><figcaption></figcaption></figure>

<h2>Cardinality - standard relations</h2>

<p>
Every relation keyword message has an alternative binary message.
</p>
<table style="border: solid thin"><tr><th>binary</th>
<th>keyword</th>
</tr>
<tr><td><code>-</code></td>
<td><code>oneToOne:</code></td>
</tr>
<tr><td><code>-*</code></td>
<td><code>oneToMany:</code></td>
</tr>
<tr><td><code>*-</code></td>
<td><code>manyToOne:</code></td>
</tr>
<tr><td><code>*-*</code></td>
<td><code>manyToMany:</code></td>
</tr>
</table>


<h2>Cardinality - aggregation</h2>

<p>
We can describe the aggregation relationship too by specifying which side of the relation is a container using similar messages like in case of the standard relations. For the binary messages, the &quot;diamond&quot; is always on the side of the owner. 
</p>
<table style="border: solid thin"><tr><th>binary</th>
<th>keyword</th>
</tr>
<tr><td><code>&lt;&gt;-</code></td>
<td><code>containsOne:</code></td>
</tr>
<tr><td><code>&lt;&gt;-*</code></td>
<td><code>containsMany:</code></td>
</tr>
<tr><td><code>-&lt;&gt;</code></td>
<td><code>oneBelongsTo:</code></td>
</tr>
<tr><td><code>*-&lt;&gt;</code></td>
<td><code>manyBelongTo:</code></td>
</tr>
</table>

<p>
Notice that there is no many-to-many aggregation relation. 
</p>
<h2>Properties of relations</h2>

<p>
Other properties can be set to the relations, for example, to comment them. Such properties are always valid only for a particular side of the relation.
</p>
<figure><pre><code>((tAccess property: #accessor)
        comment: 'Behavioural entity making the access to the variable';
        source)
    *-
((tWithAccesses property: #accesses)
        comment: 'Accesses to variables made by this behaviour.').</code></pre><figcaption></figcaption></figure>

<p>
Besides the comment, several other boolean properties can be set: 
</p>
<ul>
<li><code>container</code></li>
<li><code>derived</code></li>
<li><code>source</code></li>
<li><code>target</code></li>
</ul>

<p>
By default, none of these properties is assigned to the generated entities.

</p>
<h1>Simplified definitions</h1>

<p>
The meta-model builder provides ways to make the definition of some common constructs simpler. This chapter describes them.
</p>
<h2>Simplified traits generation</h2>
<a id="ch:simplifiedTraitsGeneration"></a>
<p>
Because traits should be the primary providers of the behavior and classes often play only a role of entities composing traits, the classes offer a simple message <code>as:</code> that can define traits related to them.
</p>
<figure><pre><code>behavior := builder newClassNamed: #Behavior.
behavior as: #TBehavior.    </code></pre><figcaption></figcaption></figure>

<p>
This code creates a new trait and then sets the class as a user of this new trait. So the code above is equivalent to: 
</p>
<figure><pre><code>behavior := builder newClassNamed: #Behavior.
(builder newTraitNamed: #TBehavior) &lt;|-- behavior</code></pre><figcaption></figcaption></figure>

<p>
In most cases, a related construct (<code>as:property:</code>) is used for the description of relations between properties without the need to separately create traits:
</p>
<figure><pre><code>method := builder newClassNamed: #Method.    
comment := builder newClassNamed: #Comment.    
    
(method as: #TMethod property: #comments) 
    -*
(comment as: #TComment property: #owningMethod).</code></pre><figcaption></figcaption></figure>

<p>
Note that the object returned by the <code>as:</code> message is not the trait created but an alias class. If you want to get the defined trait, you need to send the <code>trait</code> message to it.
</p>
<figure><pre><code>behavior := builder newClassNamed: #Behavior.
tBehavior := (behavior as: #TBehavior) trait.</code></pre><figcaption></figcaption></figure>

<p>
Of course, such traits can then be used by other classes too (with <code>&lt;|--</code>).
</p>
<h2>Automatic properties generation</h2>

<p>
Relations can be defined directly between classes. In that case, the corresponding properties are named automatically. 
</p>
<figure><pre><code>access := builder newClassNamed: #Access.    
variable := builder newClassNamed: #Variable.    
variable -* access.</code></pre><figcaption></figcaption></figure>

<p>
The example above is equivalent to the following code:
</p>
<figure><pre><code>access := builder newClassNamed: #Access.    
variable := builder newClassNamed: #Variable.    
(variable property: #accesses) 
    -*
(accessproperty: #variable).</code></pre><figcaption></figcaption></figure>

<p>
You can define relationships between any combination of classes, traits and class aliases (created using #as:) message.
</p>
<figure><pre><code>access := builder newClassNamed: #Access.    
variable := builder newClassNamed: #Variable.
(variable as: #TVariable) -* access.</code></pre><figcaption></figcaption></figure>

<h2>Associations generation</h2>
<a id="ch:AssociationsGeneration"></a>
<p>
Often you have in a meta-model a relation of two entities where you want to be able to describe more detailed properties of such relations. For example, a variable can be used in a method and you want to be able to model concrete accesses within the method. You want to know where in the code the access takes place if it is reading or storing in the variable, etc. The meta-model builder provides the method <code>link:throughAssociation:link:with:</code> that simplifies the definition of such relations that are named <em>associations</em>. The message allows you to control the names of the properties. It will be clearer with an example:
</p>
<figure><pre><code>access := builder newClassNamed: #Access.    
variable := builder newClassNamed: #Variable.    
method := builder newClassNamed: #Method.    
        
(method as: #TWithAccesses)
    link: #accesses -&gt; #accessor
    throughAssociation: (access as: #TAccess) 
    link: #variable &lt;- #incomingAccesses
    with: (variable as: #TAccessible).</code></pre><figcaption></figcaption></figure>

<p>
This will generate three traits named <code>TWithAccesses</code>, <code>TAccess</code> and <code>TAccessible</code> and define two relations between them. A collection of four relation sides are returned as result of this message. It enables to set the other properties of such relations like comments.
</p>
<figure><pre><code>sides := (method as:...)
sides first comment: 'This is a comment'.</code></pre><figcaption></figcaption></figure>

<p>
This code will set the comment of a property named <code>accesses</code> of the class <code>TWithAccesses</code>. The <code>source</code> and <code>target</code> properties are set automatically.

</p>
<h1>Code generation</h1>
<a id="ch:codeGenerationManagement"></a>
<p>
When we want to build our metamodel as extension of some already existing metamodel, we need to know the elements of the existing metamodel but do not generate it.
</p>
<figure><pre><code>builder doNotGenerateCurrent.</code></pre><figcaption></figcaption></figure>

<h1>Tutorial</h1>
<a id="ch:exampleMetamodel"></a>
<p>
In this tutorial, we will create a simple meta-model. During that, we will describe how to create own generator, use predefined traits, extend the meta-model with custom behavior and create models described by this meta-model. 
</p>
<h2>Preparation</h2>

<p>
We will start with a prebuilt Moose image based on Pharo 7 that you can find on the address <a href="https://ci.inria.fr/moose/view/Moose%206.1/job/FamixNG/lastSuccessfulBuild/artifact/FamixNG.zip">https://ci.inria.fr/moose/view/Moose%206.1/job/FamixNG/lastSuccessfulBuild/artifact/FamixNG.zip</a>
</p>
<p>
As the first step, we will create a <code>FamixMetamodelGenerator</code> subclass that will describe your meta-model. We will describe a simplified Smalltalk metamodel and our class will be named <code>DemoStMetamodelGenerator</code>. We will place it into a package of the same name. The meta-model created by this generator will use a different package.
</p>
<figure><pre><code>FamixMetamodelGenerator subclass: #DemoStMetamodelGenerator
    instanceVariableNames: ''
    classVariableNames: ''
    package: 'DemoStMetamodelGenerator'</code></pre><figcaption></figcaption></figure>

<p class="note">In this tutorial, we do not use any prepared language generator to keep things more clear and straightforward. Usually, the other generator class like <code>FmxNGBasicInfrastructureGenerator</code> would be chosen as the superclass. </p>
<p>
Then we need to specify what is the package where the meta-model will be generated. For that purpose we will create a class-side method named <code>packageName</code>. The package name must be always specified.
</p>
<figure><pre><code>DemoStMetamodelGenerator class &gt;&gt; packageName

    ^ #'DemoSmalltalkMetamodel-Generated'</code></pre><figcaption></figcaption></figure>

<p>
By default, the package name is used as the prefix of generated classes, but in our case, it is too long. So we will create a method <code>prefix</code> on the generator side of the generator that will specify it.
</p>
<figure><pre><code>DemoStMetamodelGenerator class &gt;&gt; prefix

    ^ #DemoSt</code></pre><figcaption></figcaption></figure>

<h2>Metamodel entities creation</h2>

<p>
We need to define the entities of our meta-model, like class, package or method. Firstly we will create one instance variable of in our generator for every one of them and then in the instance side method <code>defineClasses</code> we will define them as meta-model classes with a suitable name starting with an uppercase character.
</p>
<figure><pre><code>defineClasses

    entity := builder newClassNamed: #Entity.
    comment := builder newClassNamed: #Comment.
    package := builder newClassNamed: #Package.
    class := builder newClassNamed: #Class.
    method := builder newClassNamed: #Method.
    variable := builder newClassNamed: #Variable.
    attribute := builder newClassNamed: #Attribute.
    implicitVariable := builder newClassNamed: #ImplicitVariable.
    globalVariable := builder newClassNamed: #GlobalVariable.
    localVariable := builder newClassNamed: #LocalVariable.
    parameter := builder newClassNamed: #Parameter.</code></pre><figcaption></figcaption></figure>

<p class="note">We have an option to define them in this method and then let Pharo create instance variables for us automatically during the method saving.</p>
<p>
Then we can try to create the first testing generation of our meta-model:
</p>
<figure><pre><code>DemoStMetamodelGenerator new generate.</code></pre><figcaption></figcaption></figure>

<p>
We see that the package <code>DemoSmalltalkMetamodel-Generated</code> was created. For each entity, a class was created in the class category named <code>Entities</code> 
</p>
<p>
In the next step, we will specify the classes hierarchy in a method named <code>defineHierarchy</code>:
</p>
<figure><pre><code>defineHierarchy

    entity &lt;|-- package.
    entity &lt;|-- class.
    entity &lt;|-- method.   
 
    variable &lt;|-- attribute.        
    variable &lt;|-- implicitVariable.        
    variable &lt;|-- globalVariable.        
    variable &lt;|-- localVariable.        
    variable &lt;|-- parameter.    </code></pre><figcaption></figcaption></figure>

<p>
The UML description of the class hierarchy is shown in the figure <a href="#figClassHierarchy"></a>
</p>
<p>
<a id="figClassHierarchy"></a>
<figure>
	<img src="figures/demoSt-classHierarchy.png" id="figClassHierarchy" alt=""/>
	<figcaption></figcaption>
</figure>
</p>
<h2>Properties and relations</h2>

<p>
Then we will define some properties of the entities. It is very simple so we will show only one example - a comment contents.
</p>
<figure><pre><code>defineProperties

    (comment property: #content type: #String)
        comment: 'Content of the comment as a String'.</code></pre><figcaption></figcaption></figure>

<p class="note">The message <code>comment:</code> is used here to set the comment of the property. It is not related to the entity <code>comment</code> of our meta-model.</p><p>
      
In the instance side method named <code>defineProperties</code> of the generator, we defined a string property on the comment entity and added a comment.
</p>
<p>
The comment has a relation to the entities. Classes, methods and packages can be commented. The easiest way how to do that is to create a method <code>defineRelations</code>.
</p>
<figure><pre><code>defineRelations

    entity -* comment.</code></pre><figcaption></figcaption></figure>

<p>
This will set the relationship <em>one to many</em> between classes <code>DemoStEntity</code> and <code>DemoStComment</code> represented by relation slots named <code>#comments</code> and <code>#entity</code>.
</p>
<p>
Now we can start to use our meta-model for something useful. Firstly we will re-generate it (<code>DemoStMetamodelGenerator new generate</code>) and then we can write a test to prove the correct relation behavior.
</p>
<figure><pre><code>DemoStMetamodelGeneratorTest &gt;&gt; testRelations

    | aComment aClass aString |
    aString := 'some comment'.
    aComment := DemoStComment new content: aString.
    aClass := DemoStClass new.
    aComment entity: aClass.

    self assert: aComment entity equals: aClass.
    self assert: (aClass comments includes: aComment).
    self assert: aClass comments size equals: 1.
    self assert: aClass comments anyOne content equals: aString.</code></pre><figcaption></figcaption></figure>

<p>
As soon we assigned the class to the comment, the comment was automatically added to the comments collection of the class. 
</p>
<h2>Usage of standard traits</h2>

<p>
Our meta-model is now very incomplete. We, for example, cannot set the name of the class, it is missing most of the relations and so on. Moreover, if you build a model, you will not be able to use most of the advantages of Moose platform because your model classes have almost no tools support. To solve this issues, we will start to use some of the standard traits that Famix provides.
</p>
<p>
The Famix traits are placed in the package named <em>FmxNG-Traits</em>. As the first step, we need to tell to your meta-model generator, where to find them. We need to register them in your meta-model builder. The Famix traits are generated the same way as your meta-model classes - using a generator. We will take this generator and adopt its meta-model builder as a base for our own meta-model. To do that, we should override a generator's instance side method named <code>newBuilder</code>. In this method, we take the builder from the existing generator and tell him that none of the existing entities should be generated. Builder will know about them but will not create real classes nor traits for them. The message <code>builderWithStandardTraits</code> will do it.
</p>
<figure><pre><code>DemoStMetamodelGenerator &gt;&gt; newBuilder

    ^ self builderWithStandardTraits</code></pre><figcaption></figcaption></figure>

<p>
We will firstly write a test to prove that entities like classes can have a name.
</p>
<figure><pre><code>DemoStMetamodelGeneratorTest &gt;&gt; testClassName

    | aClass aString |
    aString := 'some name'.
    aClass := DemoStClass new.
    aClass name: aString.
    self assert: aClass name equals: aString.</code></pre><figcaption></figcaption></figure>

<p>
Then we can extend our meta-model classes definition (<code>defineHierarchy</code>).
</p>
<figure><pre><code>    entity --|&gt; #TNamed.</code></pre><figcaption></figcaption></figure>

<p>
This way we told to the generated class DemoSTEnitity that it should use a standard FamixNG trait named FmxNGTNamed. After re-generating of our meta-model, our tests should be green.
</p>
<p>
Now let's create a relationship between method and entities that can hold them. In Smalltalk methods can belong to classes and to packages (extension methods).  We will open the tool named &quot;Famix trait groups&quot; from the Moose menu where we will find suitable trais in categories &quot;Method&quot; and &quot;Package.&quot;
</p>
<p>
<a id="Method"></a>
<figure>
	<img src="Chapters/ExampleMetamodel/figures/Method.svg" width="23%" id="Method" alt="Method"/>
	<figcaption>Method</figcaption>
</figure>
</p>
<p>
<a id="Package"></a>
<figure>
	<img src="figures/Package.svg" width="25%" id="Package" alt="Package"/>
	<figcaption>Package</figcaption>
</figure>
</p>
<p>
We will add a standard trait <code>TMethod</code> to our <em>method</em> entity and a trait named <code>TWithMethods</code> to the entity <em>class</em>. Then we will say that methods and classes are <em>packageable</em> and the package uses a trait named <code>TPackage</code>.
</p>
<figure><pre><code>    method --|&gt; #TMethod.
    class --|&gt; #TWithMethods.
    package --|&gt; #TPackage.
    class --|&gt; #TPackageable.
    method --|&gt; #TPackageable.</code></pre><figcaption></figcaption></figure>

<p>
You may ask why the <em>package</em> does not use the <code>TWithMethods</code> trait too. The pair of traits <code>TWithMethods</code> and <code>TMethod</code> defines relationship <em>methods</em> - <em>parentType</em>. Of course, the package is not a parent type for the method and because the method can belong to a class and package simultaneously, it would cause a collision.
</p>
<p class="note">Our meta-model has no entity that can contain packages. We will not apply the trait <code>TWithPackages</code> to any class. The property <code>packageOwner</code> of the DemoSTPackage will always return nil. </p>
<p>
With such meta-model, we can start to build more complex models.
</p>
<figure><pre><code>| model class package1 package2 method1 method2 |

model := MooseModel new
    metamodel: DemoStMetamodelGenerator metamodel;
    yourself.

class := DemoStClass new name: #Class1.
package1 := DemoStPackage new name: #Package1.
package2 := DemoStPackage new name: #Package2.
method1 := DemoStMethod new name: #method1.
method2 := DemoStMethod new name: #method2.
class parentPackage: package1.
method1 parentType: class.
method2 parentType: class.
method2 parentPackage: package2.
model addAll: { class. package1. package2. method1. method2 }.</code></pre><figcaption></figcaption></figure>

<p>
Notice that <code>isStub</code> is a property added by the trait <code>TNamed</code>. When we will inspect such model in Moose, the inspector will provide more advanced options like showing all methods in the meta-model, because we used the trait <code>TMethod</code> on some of the elements and thus they are interpreted as methods. 
</p>
<h2>Custom extensions</h2>

<p>
During generation of the meta-model classes, the generator touches only the methods and slots it knows they can be changed. In case we want to provide an alternative code for generated methods, we need to remove the pragma <code>&lt;generated&gt;</code> else the generator will rewrite them during the next re-generation. 
</p>
<p>
As we said, the generator creates for every meta-model entity two classes. One has a name with the suffix <em>Generated</em> and is the superclass of the other one. When such pair is created, the generator only checks if the class without suffix already exists and if yes, it stays untouched. That opens a possibility to move them to a separate package and extend such classes with own methods or instance variables if needed. 
</p>
<p>
We want, for example, from methods to answer a package that owns method in case that the method package is not explicitly known. In this case we need to remove pragma <code>&lt;generated&gt;</code> from the parentPackage accessor.
</p>
<figure><pre><code>DemoStMethod &gt;&gt; parentPackage

    &lt;MSEComment: 'Package containing the entity in the code structure (if applicable)'&gt;
    &lt;container&gt;

    ^ super parentPackage ifNil: [ self parentType parentPackage ]</code></pre><figcaption></figcaption></figure>

<p>
Of course, now we have full responsibility of keeping such classes and method synchronized with the generated meta-model.
</p>
<h2>Importing context customization</h2>

<p>
Together with the classes for the meta-model entities, an importing context can be created. To do so, we need to specify it in the <code>newBuilder</code> method of our generator.
</p>
<figure><pre><code>newBuilder

    ^ self builderWithStandardTraits
        generateImportingContext: true;
        yourself</code></pre><figcaption></figcaption></figure>

<p>
In our case, it is automatically named as <code>DemoStImportingContext</code>. This class will be useful for you as soon as you will start to write or customize an importer for your models. 
</p>
<p>
The main task we need to do is to set dependencies between the meta-model elements. Simply use the message <code>requires:</code> that accepts a collection of entities required by another entity.
</p>
<figure><pre><code>method requires: { class }.</code></pre><figcaption></figcaption></figure>

<p>
Then a user of an importer of your models can create a related importing context like this:
</p>
<figure><pre><code>importerTask importingContext: (DemoStImportingContext new 
    importPackage;
    importMethod;
    yourself).</code></pre><figcaption></figcaption></figure>

<p>
During import of a model then can the importer ask the importing context if the user wanted some data with an expression like this:
</p>
<figure><pre><code>self importingContext shouldImportClass</code></pre><figcaption></figcaption></figure>

<p>
In our case, the answer will be true because the user asked for the importing of methods and we defined classes as dependencies of methods. The names of methods with prefix <em>import</em> and <em>shouldImport</em> are generated automatically.
</p>

</p>




  </div>
</div>
</div>
</section>
	

    <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
    <script src="https://code.jquery.com/jquery.js"></script>
    <!-- Include all compiled plugins (below), or include individual files as needed -->
    <script src="_support/html/js/bootstrap.min.js"></script>

    <!-- Syntax highlighting of code blocks -->
    <script>hljs.initHighlightingOnLoad();</script>

    <!-- Prettify annotated paragraphs-->
    <script src="_support/html/js/annotated-paragraphs.js"></script>

	<footer class="site-footer">
  <div class="container">
    <p class="powered-by">

      Powered by the
      <a href="https://sourcethemes.com/academic/" target="_blank" rel="noopener">Academic theme</a> for
      <a href="https://github.com/pillar-markup/pillar" target="_blank" rel="noopener">Pillar</a>.

      <span class="pull-right" aria-hidden="true">
        <a href="#" id="back_to_top">
          <span class="button_icon">
            <i class="fa fa-chevron-up fa-2x"></i>
          </span>
        </a>
      </span>

    </p>
  </div>
</footer>



  </body>
</html>
