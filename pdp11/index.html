<!DOCTYPE html>
<html>
<!-- OverType: The Over-The-Top Typewriter Simulator, by Ben Wheeler -->
<!-- Copyright (C) 2014-2015 Ben Wheeler. All rights reserved. Absolutely no warranty, express or implied. -->
	<head>
		<meta charset="utf-8"> 
		<title>PDP-11</title>
		<style type="text/css" media="all">
			body {
				font-family: Helvetica, sans-serif;
				font-size: 14px;
				line-height: 20px;
				background-color: #333;
				margin: 0;
			}
			h1 {
				margin-top: 0;
				margin-bottom: 0;
				font-family: Courier, "Courier New", monospace;
				font-weight: bold;
				font-size: 40px;
			}
			h2 {
				margin-top: 0;
				font-size: 20px;
			}
			h3 {
				font-size: 16px;
			}
			.bars {
				position: fixed;
				top: 0;
				left: 0;
				z-index: 9;
				width: 100%;
			}
			.topbar {
				padding: 1ex 0% 2px 1%;
				background-color: white;
				height: auto;
				display: none;
			}
			.info {
				font-family: Courier, 'Courier New', monospace;
				top: 6em;
				padding: 8em 4em;
				max-width: 900px;
				margin-left: auto;
				margin-right: auto;
				background-color: #eee;
				display: none;
			}
			.buttonbar {
				clear: both;
				background-color: #eee;
			}
			.buttons {
				display: none;
			}
			.buttons.left {
				float: left;
			}
			.buttons.right {
				float: right;
			}
			.instruct {
				font-size: 18px;
				color: #666;
				background-color: #eee;
			}
			.instruct ul ul {
				font-size: 16px;
			}
			#Carriage {
				font-family: Courier, "Courier New", monospace;
				font-size: 20px;
				line-height: 30px;
				position: absolute;
				left: 50%;
				margin-left: -26em;
				top: 0;
				//height: 165ex;
				height:20ex;
			}
			.output {
				margin-bottom: 2em;
				position: relative; /* within position:absolute #Carriage */
				width: 52em;
				//height: 160ex;
				height: 20ex;
				left: 0;
				top: 0;
				background-color: white;
				background-image: url(handmadepaper.png);
				border: 1px solid black;
				/*  box-shadow: 8px 8px 4px #888; */
				white-space: nowrap;
				z-index: 2;
			}
			.cursor {
				position: absolute;
				z-index: 4;
				/*border: 2px solid red;
				display: none;*/
			}
				
			.title {
				float: left;
				width: 550px;
			}
			.controls {
				margin: 0 1em;
				float: right;
			}
			.control {
				float: left;
				width: 150px;
				margin: 0 1ex;
			}
			.control h4 {
				margin: 0 0 8px 0;
				text-align: center;
			}
			.control .disp {
				margin: 4px 0 0 0;
				text-align: center;
			}
			
			@font-face {
				font-family: 'GNUTypewriterStandard';
				src: url('GNUTypewriterStandard.ttf') format('truetype');
				font-weight: normal;
				font-style: normal;
			}

 /* The following rules are deprecated. */ 

@font-face {
    font-family: 'GNUTypewriter';
        src: url('GNUTypewriterStandard.ttf') format('truetype');
    font-weight: normal;
    font-style: normal;
      }
      
      
		#terminal {
			font-family: monospace;
			width: 100%;
			height: 10cm;
			position: absolute;
			
			top: 200px;
opacity: 0.1;
display: none;

		}
		#debug {
			font-family: monospace;
			width: 100%;
			height: 5cm;
			display: none;
		}
      
		.controls {
			position: absolute;
			z-index: 100;
			display: none;
		}
	     
		</style>
		<style type="text/css" media="print">
			.title, .controls, .topbar, .cursor { display: none !important; }
			.output { box-shadow: none; border: none; padding: 10ex 0 0 0; background-image: none; }
			#Carriage { left: 0 !important; top: 0 !important; left: 5em; margin-left: 0;}
			body { background-color: white; }
		</style>
		<!-- jQuery -->
		<script type="text/javascript" src="jquery.min.js"></script>
		<!-- jQuery-UI (for the sliders, and the accordion on the info page) -->
		<link rel="stylesheet" href="jquery-ui.css" />
		<script src="jquery-ui.min.js"></script>		
		<!-- ION.Sound -->
		<script type="text/javascript" src="ion.sound.min.js"></script>
		<!-- Special Elite font -->
		<link href="https://fonts.googleapis.com/css?family=Special+Elite" rel="stylesheet" type="text/css">
		<!-- GNUTypewriter font -->
		<!--<link href="https://fontlibrary.org/face/gnutypewriter" rel="stylesheet" type="text/css"/> -->		

		<script src="disasm.js" type="text/javascript"></script>
		<script src="cons.js" type="text/javascript"></script>
		<script src="rk05.js" type="text/javascript"></script>
		<script src="pdp11.js" type="text/javascript"></script>


		<script type="text/javascript">
			// "use strict";
			const bell_width = 72-5;
			const max_width = 72-1;
			const tab_width = 8;
			const xpx = 12;  // characters width/heigth
			const ypx = 30;
			const char_height = 20;
			const margin_top = 40, margin_left = 90;
			const max_brokenness = 99;
			const max_ink_level = 600;
			// These values are used for shift lock if we have not yet mapped the real value of the shifted char 
			// by pressing it with shift held down.


			const shifted = { /*
				'§': '±',
				'1': '!',
				'2': '@',
				'3': '£',
				'4': '$',
				'5': '%',
				'6': '^',
				'7': '&',
				'8': '*',
				'9': '(',
				'0': ')',
				'-': '_',
				'=': '+',
				'[': '{',
				']': '}',
				';': ':',
				'\'': '"',
				'\\': '|',
				',': '<',
				'.': '>',
				'/': '?',
				'`': '~',  */
			};
			var typingSpeed = 50;
			var pageScrollSpeed = 200;
			var real_shifted = {};
			var x = 0 * xpx;
			var y = ypx;
			var vmid = $(window).height() / 2;
			var hmid = $(window).width() / 2;
			var voffset = {};
			var broken = {};
			var brokenness = 15;
			var ink_remaining = 280;
			var ink_variation = 0.3;
			var keydown_keys = {};
			var keypress_keys = {};
			var cr_mutex = false;
			var keydown_keycode = false;
			var shift_mutex = false;
			var alt_mutex = false;
			var capslock_pressed_recently = false;
			var started = true;
			var redshift = false;
			var shift_lock = false;
			var redshift_lock = false;
			var spoolPosition = 1;
			
			var headImage = "head.png";
			
			var printBuffer = [];
			
			function getRandomInt(min, max) {
				return Math.floor(Math.random() * (max - min + 1)) + min;
			}

			function start() {			
				$('.buttons, .output, .cursor').show();
				started = true;
			}
			function stop() {
				$('.buttons, .output, .cursor').hide();
				started = false;
			}
			function keydown_capslock(e) {
				// If already locked, unlock
				if (shift_lock || redshift_lock) {
					shift_lock = false;
					redshift_lock = false;
					$.ionSound.play('typewriter-keyup-2');
				}
				// Otherwise, lock whatever is being held
				if (e.shiftKey) {
					shift_lock = true;
				}
				if (redshift) {
					redshift_lock = true;
				}
			}

			function keydown_redshift(e) {	
				e.preventDefault();					
				if (redshift_lock) {
					return false;
				}
				if (redshift) {
					// Already being held down
					// For some reason, esc is auto-repeating and triggering keydown repeatedly when held.
					return true;
				}
				$.ionSound.play('typewriter-spacebar');
				redshift = true;
			}				

			function keydown_shift(e) {
				if (shift_mutex || shift_lock) {
					return false;
				}
				$.ionSound.play('typewriter-spacebar');
				shift_mutex = true;
			} 
			
			function keydown_alt(e) {
				e.preventDefault();
				if (alt_mutex) {
					return false;
				}
				$.ionSound.play('typewriter-spacebar');
				alt_mutex = true;
			}

			function crlf() {
				// Carriage return sets its own mutex, which prevents any other keydown (including another enter) 
				// from working until the return has finished.
				cr_mutex = false; //!
 				// If we're not already at the beginning of the line, start playing the return motion sound
				var line_length = x / xpx;
				var return_time = 13 * line_length;
				y += ypx;
				
				cr_mutex = false;
				x = 0;
			}	
			
			function keydown_cursor_up(e) {
				e.preventDefault();
				e.stopPropagation(); 
				if (y > 0) {
					y -= (ypx / 4);
					$.ionSound.play('typewriter-spacebar');
			///		move_page();
				}
			}

			function keydown_cursor_down(e) {
				e.preventDefault();
				e.stopPropagation(); 
				$.ionSound.play('typewriter-spacebar');
				y += (ypx / 4);
			///	move_page();
			}

			function keydown_cursor_left(e) {
				e.preventDefault();
				e.stopPropagation(); 
				if (x > 0) {
					x -= xpx;
					$.ionSound.play('typewriter-spacebar');
			///		move_page();
				} 
			} 

			function keydown_cursor_right(e) {
				e.preventDefault();
				e.stopPropagation(); 
				advance_one_space();
				if ((x / xpx) == bell_width) {
					$.ionSound.play('typewriter-bell-2');
				} else {
					$.ionSound.play('typewriter-spacebar');
				}
		///		move_page();
			} 
			
			// shared between keydown_cursor_right() and keypress()
			function advance_one_space() {
				if ((x / xpx) < max_width) {
					x += xpx;
				}
			}
			
			function keydown_tab(e) {
				e.preventDefault(); // Don't lose focus
				var oldx = x;
				if (e.shiftKey || shift_lock) {
					var prev_tab_stop = ((x / xpx) % tab_width);
					if (prev_tab_stop == 0) {
						prev_tab_stop = tab_width;
					} 
					if ((x / xpx) - prev_tab_stop < 0) {
						prev_tab_stop = x;
					}
					x -= (prev_tab_stop * xpx); 
				} else {
					var next_tab_stop = tab_width - ((x / xpx) % tab_width);
					if (next_tab_stop == 0) {
						next_tab_stop = tab_width;
					} else if ((x / xpx) + next_tab_stop > max_width) {
						next_tab_stop = max_width - (x / xpx);
					}
					x += (next_tab_stop * xpx);
				}
				if ((oldx / xpx) < bell_width && (x / xpx) >= bell_width) {
					$.ionSound.play('typewriter-bell-2');
				}	else {				
					$.ionSound.play('typewriter-spacebar');
				}
			///	move_page();
			}
			
			function keypress(e) {
				
			//	console.log("keypress "+e.charCode);
				//lastChar = e.charCode;
				// Prevent browser special key actions as long as ctrl/alt/cmd is not being held
				if (! e.altKey && ! e.ctrlKey && ! e.metaKey) {
				e.preventDefault();
					e.stopPropagation();
				}
				// If we are in the middle of a CR, ignore this keypress
				// If this key is already being held down, ignore this keypress (keyboard auto-repeat may fire multiple events)
			//	if (cr_mutex || keypress_keys[keydown_keycode]) {
			//		return;
			//	}
				// Don't handle keys that are handled by keydown functions
				// These will all have charCode 0, which is the only way of distinguishing them from chars which have the
				// same value on Chrome which sets keyCode to match charCode in keypress handlers. (eg in a keydown handler
				// keyCode 39 is right-arrow, while in a keypress handler, it's the quote character ' )
				if (e.charCode == 0) {
					// Note the use of keyCode here so these numbers will match the keydown ones
					switch (e.keyCode) {
						case 8:
						case 9:
						case 13:
						case 37:
						case 38:
						case 39:
						case 40:
						case 16:
						case 18:
						case 20:
						case 27:
						case 17:
						case 224:
							return false;
					}				
				}
				// Record the keypress for mutex purposes, even if we're not going to act on it
				keypress_keys[keydown_keycode] = 1; // Have to use charCode as that's the only one available to both keypress and keyup
				// Only one printing keypress allowed at a time
				// console.log('PRESS: ' + keydown_keycode + " keydown_keys " + Object.keys(keydown_keys).toString() + " keypress_keys " + Object.keys(keypress_keys).toString());
				if (Object.keys(keypress_keys).length > 1) {
					return false;
				}
				
if ((e.charCode != 10) && (e.charCode != 13)) {
	
			
							addchar(e.charCode);
							specialchar(e.charCode);
			}				

				//typeCharacter(e.charCode, e.shiftKey);;
			}	
	
			function typeCharacter(charCode, shiftKey) {
			
				printBuffer.unshift(charCode);
			
			
			}
			
			function printer() {
				setTimeout(function(){
					var delay = typingSpeed;
					if (printBuffer.length > 0)
					{
						var code = printBuffer.pop();
						typeCharacter2(code);
						//if (code = 32) delay /= 2 ; 
						
					}
					setTimeout(printer, delay);
				}, typingSpeed);
			
			}
			


			function typeCharacter2(charCode, shiftKey) {
					
			//	console.log(charCode);
								
				var nosound = false;

				if (charCode == 13) return; // ignore
				if (charCode == 0) return; // ignore
				if (charCode == 10) {
					crlf();
					move_page();
					}
			
				if (charCode != 32 && charCode != 127)
					$("#cursorImage").attr("src","head2.png");

				var c;
				c = String.fromCharCode(charCode);//.toUpperCase();
			//	console.log(c);
				
				
				if (charCode == 127) c = " "; 
/*
				if ( charCode >= 65 && charCode <= 90 ) {
					// We only want upper case letters if shifted (so caps lock doesn't do them if it's only being used for colourshift lock)
					if (! shiftKey && ! shift_lock) {
						c = c.toLowerCase();
					} 
				} else if (shiftKey) {
					real_shifted[keydown_keycode] = c; // Learn the real shifted char
					// console.log("Storing " + keydown_keycode + " -> " + c);
				} else if (shift_lock) {
					if (keydown_keycode > 0 && real_shifted[keydown_keycode]) {
						// Use the real shifted char if we learned it
						c = real_shifted[keydown_keycode]; 
						// console.log("Retrieving " + keydown_keycode + " -> " + c);
    			} else if (shifted[c]) {
						// Otherwise fall back to the default shifted char mapping
						// console.log("Using default shiftmap for " + c)
						c = shifted[c]; 
						// console.log(" -> " + c);
					}
				}
*/
				// Vertical offset
				if (! (c in voffset)) {
					voffset[c] = {
						threshold: Math.floor(Math.random() * 99) + 1, // 1..99
						direction: Math.floor(Math.random() * 3) - 1, // -1..+1
					}						
				}
				
				extra_offset = 0;
				// Extra offset if highly broken
				extra_offset = Math.floor(Math.random() * brokenness / 25); // 0 at b<50, 0..1 at 50<=b<75, 0..2 at b>=75
				if (voffset[c].direction < 0) {
					extra_offset = -extra_offset;
				}
				
				this_voffset = (voffset[c].threshold <= brokenness) ? Math.round(voffset[c].direction * brokenness / 33) : 0;
				this_voffset += extra_offset;
				
				// If brokenness >75%, let some keys be permanently broken.
				// The chance of a key being broken increases with brokenness; once broken, it remains so until brokenness is reduced
				// below 75% whereupon they are all fixed.
				if (brokenness > 75) {
					// Randomly break keys with a likelihood and a maximum number of broken keys that depend on the brokenness level
					if (c != '&nbsp;' && (broken[c] || (Math.random() * brokenness > 70 && Math.random() < 0.4 && Object.keys(broken).length < (brokenness - 75) / 5))) { 
						if (Math.random() > 0.7) {
							broken[c] = '&#9608;'; // full block - as if the embossed character has fallen off the arm.
						} else {
							broken[c] = '&nbsp;'; // as if the key doesn't work at all or is missing
							nosound = true;
						}
					}
				} else {
					broken = {};
				}

				// Output the character, unless it's broken
				if (broken[c]) {
					c = broken[c];
				}

				output_character(c, this_voffset, '.output');

				if (charCode != 10) {
					advance_one_space();
				}
				if (charCode == 127) {
					advance_one_space();
					advance_one_space();
					advance_one_space();
				}

				if (c.match(/\S/)) {
					ink_remaining = ink_remaining - 0.02;
				}
				
				if ((x / xpx) == bell_width) {
					$.ionSound.play('typewriter-bell-2');
				} else if (! nosound) {
					// $.ionSound.stop('typewriter-keyup-2');
					switch (charCode)
					{
						case 32:
						case 127:
							$.ionSound.play('type-space');
							break;
						default:
							$.ionSound.play('type2');
					}
				} 

				// Update ink level slider and disp
				$('#ctrl_inklevel').slider('option', 'value', ink_remaining);
				$('#disp_inklevel').html(ink_remaining);		
				setCursorPosition();
				
				setTimeout(function(){
					if (charCode != 32 && charCode != 9) {
					//	console.log('spool: '+spoolPosition);
						switch (spoolPosition) {
							case 1: 
								headImage = "head.png";
								break;
							case 2: 
								headImage = "head3.png";
								break;
							default: 
								headImage = "head4.png";
						}
						spoolPosition = ((spoolPosition)%3)+1;
					
						
					}
					
 $("#cursorImage").attr("src",headImage);
}, typingSpeed);
				
				
		
			}

			function output_character(c, this_voffset, where) {
				// Choose an alpha level with a random element to simulate uneven key pressure and ribbon ink
				var ink_level = (ink_remaining > 0) ? ink_remaining / 400 - ink_variation + Math.random() * ink_variation : 0;
				//	console.log(ink_level);
				
				var hpos = 'left: ' + (x + margin_left) + 'px; ';
				var vpos = 'top: ' + (y + this_voffset + margin_top) + 'px; ';
								
				var black_height = ypx;
				var black_height_style = '', red_height_style = '';
				var base_colour = '0,0,0';
				// TODO: Make high brokenness do partial red chars sometimes without redshift, and/or permanently lose part of the char.
				//       The relative probabilities of black and red need to be the opposite of what they are for redshift 
				//       but without reversing the relative positions. voffset also needs to work oppositely.
				//       I think I need to track the position of the print head relative to the ribbon.
				if (redshift || redshift_lock) {
					if (Math.random() < brokenness / 100) {
						// Colour part of the character black, to simulate not pressing Colour Shift hard enough.
						// Black height depends on brokenness level and voffset. As the black creeps in from the top,
						// a char with high negative voffset (shifted upwards) will be more blackened.
						// +ypx-char_height because that is empty space before the top of the visible character.
						black_height = Math.floor(Math.random() * ypx * brokenness / 250) + ypx - char_height - this_voffset;
						if (black_height < 0) {
							black_height = 0; // All red
							red_height_style = '';
						} else {
							black_height_style = 'clip: rect(0px, ' + xpx + 'px, ' + black_height + 'px, 0px); ';
							red_height_style   = 'clip: rect(' + black_height + 'px, ' + xpx + 'px, ' + ypx + 'px, 0px); ';
						}
					} else {
						black_height = 0;
						red_height_style = '';
					}
					// Output the (possibly partial) character in red					
					$(where).append('<div style="position: absolute; ' + vpos + hpos + ' color: rgba(255, 0, 0, ' + ink_level + '); ' + red_height_style + '">' + c + '</div>');
				} 
				if (black_height > 0) {
					// Output the (possibly partial) character in black
					$(where).append('<div style="position: absolute; ' + vpos + hpos + ' color: rgba(' + base_colour + ', ' + ink_level + '); ' + black_height_style + '">' + c + '</div>');
					
					// Maybe output further subcropped character(s) in black to make the colouring more uneven
					for (var subclips = 0; subclips < 3; subclips++) {
						var subclip_right = Math.floor(Math.random() * xpx) + 1;
						var subclip_left = Math.floor(Math.random() * subclip_right);
						var subclip_bottom = Math.floor(Math.random() * black_height) + 1;
						var subclip_top = Math.floor(Math.random() * subclip_bottom);
						var r = Math.random();
						var sign = Math.random() < 0.5 ? -1 : 1;
						var b = brokenness / (max_brokenness + 1); // max_brokenness is 99, but let's use a percentage
						var i = ink_remaining / max_ink_level;
						// Thanks to John Valentine for help with the following formula
						var subclip_opacity = i * (0.5 + 0.5 * Math.sqrt(r * b) * sign); 
						var subclip_color = 'color: rgba(' + base_colour + ', ' + subclip_opacity + '); ';
						var subclip_clip = 'clip: rect(' + subclip_top + 'px, ' + subclip_right + 'px, ' + subclip_bottom + 'px, ' + subclip_left + 'px); ';
						// console.log("sign: " + sign + " r: " + r + " b:" + b + " i: " + i + " result: " + subclip_opacity);
						$(where).append('<div style="position: absolute; ' + vpos + hpos + subclip_color + subclip_clip + '">' + c + '</div>');
					}
				}
			}


			function keydown_nonmod(e) {
				// Because the keypress event does not make keyCode available for normal chars, we have to store it in the keydown handler
				// so it can be referenced in the keypress handler to relate shifted chars to their keys so we can retrieve them 
				// when shiftlock is on. This relies on the keydown event firing before the keypress event, and getting at least as 
				// far as setting keydown_keycode before the keypress handler reads it. This is the kind of yucky race condition it's
				// normally best to avoid, but in practice it seems to Just Work in all the browsers I've tried.
				// We need to store this value whether or not we do anything with this keydown, so that the associated keypress event
				// gets the right one even if multiple keys are being held down.
				keydown_keycode = e.keyCode;

				// Always record the keydown for mutex purposes, even if we aren't going to act on it
				keydown_keys[e.keyCode] = 1;
				// console.log('DOWN: ' + e.keyCode + " keydown_keys " + Object.keys(keydown_keys).toString() + " keypress_keys " + Object.keys(keypress_keys).toString());
				// Only one non-modifier key may be pressed at a time. So if this is the 2nd or subsequent being held, ignore this one.
				if (Object.keys(keydown_keys).length > 1) {
					return false;
				}
				switch (e.which) {
					case 9:  // tab
					    if (e.charCode == 0) {
							e.preventDefault(); 
						//	console.log("TAB");
							e.preventDefault()
//							addchar(9);
							specialchar(9)
						}

						break;
		//				keydown_tab(e);
			//			break;
					case 13: // enter
						
							addchar(13);
							specialchar(13);
					
						break;
					case 46:  // del
					    if (e.charCode == 0) {
							e.preventDefault(); 
						//	console.log("DEL");
							specialchar(46);
							printBuffer = [];
						}
						//addchar(46);
						//specialchar(127);
						break;


			//			keydown_enter(e);
			//	addchar(13);
			//	specialchar(13)
			//			break;
					default: // all other characters are handled by the keypress handler
				}
			}
			
			
			function keydown(e) {
			//	console.log("keydown");
			//	console.log(e.charCode+" - "+e.keyCode);
				
				if (! started) {
					start();
				}
				// If we are in the middle of a CR, ignore this key entirely
				if (cr_mutex) { 
					return;
				}
				// If this key is already being held down, ignore it (keyboard auto-repeat may fire multiple events)
				// UNLESS it's a cursor key - we allow auto-repeat on those because otherwise moving is tedious.
/*				if (keydown_keys[e.keyCode] && (e.keyCode < 37 || e.keyCode > 40)) {
					return;
				}
*/				switch (e.which) {
	/*				case 16:
						keydown_shift(e);
						break;
					case 18:
						keydown_alt(e);
						break;
					case 20:
						// To cope with Chrome/Mac, FF/Mac, and all Windows&Linux browsers work in 3 different ways wrt caps lock,
						// we have to jump through extra hoops. Start a timer here, and check in keyup.
						capslock_pressed_recently = true;
						setTimeout(function() {
							capslock_pressed_recently = false;
						}, 1500);
						keydown_capslock(e);
						break;
	*/				case 27: // esc - ignore
					case 17:	// ctrl - ignore
					case 224: // cmd - ignore
						break;
					default:
						keydown_nonmod(e);
				}
				return; //return true;
				
				
				keydown_nonmod(e);
			}
			
			function move_page() {
		
				$('#Carriage').attr('height', '+='+ypx+'px');
 			
				$(function () {
					$('#Carriage').animate({
						top: (vmid - y) + 'px',
					}, { duration: pageScrollSpeed, queue: false });

					$('.output').animate({
						height: '+='+ypx+'px',
					}, { duration: pageScrollSpeed, queue: false });
				
					$('.cursor').animate({
						top: (y + 10) + 'px',
					}, { duration: pageScrollSpeed, queue: false });
				});		
			}

			// Handler for keyup events
			function keyup(e) {
		//		console.log("keyup");
								
				if (e.which == 2000) {
					keyup_capslock();
				} else if (shift_mutex && e.which == 1600 && ! e.shiftKey) {
					if (! shift_lock) {
						$.ionSound.play('typewriter-keyup-2');
					}
					shift_mutex = false;
				}	else if (alt_mutex && e.which == 1800 && ! e.altKey) {
					$.ionSound.play('typewriter-keyup-2');
					alt_mutex = false;
				}	else if (redshift && e.which == 2700) {
					if (! redshift_lock) {
						$.ionSound.play('typewriter-keyup-2');
					}
					redshift = false;
				} else if (Object.keys(keydown_keys).length /* && e.which != 13 */ ) { // CR does its own sound and mutex release
					// console.log('UP: ' + e.keyCode + " keydown_keys " + Object.keys(keydown_keys).toString() + " keypress_keys " + Object.keys(keypress_keys).toString());
					if (Object.keys(keypress_keys).length == 1) { // Only move the page if this is the last keypress being held
			///			move_page();
					}
					// Play the key release sound and release the mutexes after a short delay
				/*	setTimeout(function() {
						$.ionSound.play('typewriter-keyup-2');
						delete keydown_keys[e.keyCode];
						delete keypress_keys[e.keyCode];
					}, 5); */
					delete keydown_keys[e.keyCode];
					delete keypress_keys[e.keyCode];
				}
			}

			// Special keyup handling is necessary for caps lock
			// On Firefox/Mac, each press of caps lock only fires keydown
			// On Chrome/Mac, the first press of caps lock only fires keydown, and the second press only fires keyup,
			// as if the key had been held down for all the time that its light was on. (Safari is the same.)
			// On other browsers, it behaves like a normal key, ie it gets a keydown event when first pressed, 
			// possibly further keydown events on auto-repeat, and a keyup event when released.
			// So everything apart from Chrome/Mac can be handled by a keydown handler as long as it's not held down
			// long enough to auto-repeat. But for Chrome/Mac we might need to act on a keyup. 
			// So when there's a capslock keydown event, we set capslock_pressed_recently=true and set a timer to set
			// it to false after an interval. Then on a keyup event, here we check that flag; if it's still true, 
			// assume it was a single press event keydown+keyup
			function keyup_capslock() {
				if (! capslock_pressed_recently) {
					// Looks like this is a lone keyup event on a webkit browser which means the key was pressed a second time.
					// So fire the keydown handler.
					keydown_capslock();
				}
			}
			
			function setCursorPosition() {
				$(function () {
					$('.cursor').animate({
						left: ( x - 185) + 'px',
					}, { duration: typingSpeed, queue: false });
				});					
			}			

			// onLoad setup
			$(function() {
				// Check browser supports rgba() colours (stolen from Modernizr)
				var rgba_check = function() {
					var elem = document.createElement('div');
    			var style = elem.style;
					style.cssText = 'background-color:rgba(150,255,150,.5)';
					return ('' + style.backgroundColor).indexOf('rgba') > -1;
				};
				if (! rgba_check()) {
					$('.warning-rgba').dialog();
					return false;
				}
				
				// Accordion for info page
				$('#InfoAccordion').accordion({
					heightStyle: 'content',
				});

				// Handle font selector, and initialise font
				$('.fontsel').change(function() {
					$('#Carriage').css('font-family', $(this).val());
				});
				$('#Carriage').css('font-family', $('.fontsel:checked').val());

				// Sliders
				$('#ctrl_brokenness').slider({
					min: 0,
					max: max_brokenness,
					value: brokenness,
					slide: function(event, ui) {
						$('#disp_brokenness').html(ui.value);
					},						
					change: function(event, ui) {
						brokenness = ui.value;
						ink_variation = 1.0 * brokenness / 100;
					},
				});
				$('#ctrl_inklevel').slider({
					min: 0,
					max: max_ink_level,
					value: ink_remaining,
					slide: function(event, ui) {
						$('#disp_inklevel').html(ui.value);
					},						
					change: function(event, ui) {
						ink_remaining = ui.value;
					},
				});
				// When the sliders or font selector are clicked, they gains focus. We don't want them to keep focus or they will use some keypresses.
				$('.ui-slider-handle, .fontsel').focus(function() {
					$(this).blur();
				});

				$('#disp_brokenness').html(brokenness);
				$('#disp_inklevel').html(ink_remaining);
				
				move_page();
	//			$('.cursor').css('top', y*ypx + 46).css('left', x*xpx + 31); // Magic numbers basically arrived at by trial and error...
	//			$('.cursor').css('top', ypx).css('left', margin_left+x*xpx ); // Magic numbers basically arrived at by trial and error...
				setCursorPosition();
				$.ionSound({
					path: "",
					sounds: [
							// { name: "typewriter-keydown-2" },
							{ name: 'type2' },
							{ name: 'type-space' },
							{ name: 'typewriter-keyup-2' },
							{ name: 'typewriter-carriage-return-main' },
							{ name: 'typewriter-carriage-return-stop' },
							{ name: 'typewriter-spacebar' },
							{ name: 'typewriter-bell-2' },
					],
					multiplay: true,
					preload: true,
				});
				// Have to use both keydown and keypress events.
				// keypress doesn't fire for backspace in Chrome, and modifier keys in general.
				// keydown only gives us key codes, not the character that they should produce on this specific keyboard.
	if (true) {
				$(document)
				.on('keydown', function(e) { 
					// console.log("keydown: " + e.which + " keydown_keys " + Object.keys(keydown_keys).toString() + " keypress_keys " + Object.keys(keypress_keys).toString());
					keydown(e); 
				}) 
				.on('keypress', function(e) {
					// console.log("keypress: " + e.which + " keydown_keys " + Object.keys(keydown_keys).toString() + " keypress_keys " + Object.keys(keypress_keys).toString());
					keypress(e);
				})
				.on('keyup', function(e) {
					// console.log("keyup: " + e.which + " keydown_keys " + Object.keys(keydown_keys).toString() + " keypress_keys " + Object.keys(keypress_keys).toString());
					keyup(e);
				}); // on() 
		}
			}); //$()
		</script>
	</head>
	<body  onload="reset(); rkinit(); run(); printer();">
		
		<div class="controls">
		<input type="button" value="reset" onclick="reset()" />
		<input type="button" value="run" onclick="run()" />
		<input type="button" value="stop" onclick="stop()" />
		<span id="ips"> </span>
		<span id="rkbusy" style='display: none'>hard disk busy</span>
		</div>

		<div>type <tt>unix</tt> at the <tt>@</tt> prompt to load the kernel, enjoy! <a href="http://aiju.de/code/pdp11/faq">faq</a></div>
		<textarea id="terminal" readonly="readonly" onkeypress="addchar(event.which)" onkeyup="specialchar(event.which)"> </textarea>
		<textarea id="debug" readonly="readonly"> </textarea>

		
		<div class="bars">
			<div class="topbar">
				<div class="title">
					<h1><img src="overtype_logo.png" alt="OverType" height="40"></h1>
					<h2 style="margin-bottom: 0"><img src="overtype_subhead.png" alt="The Over-The-Top Typewriter Simulator" height="27"></h2>
				</div>
				<div class="controls">
					<div class="control">
						<h4 style="text-align: right; margin: 0 0 0 20px">Font:</h4>
					</div>
					<div class="control">
						<div>
							<label>
								<input class="fontsel" type="radio" name="font" value="Courier, 'Courier New', monospace" checked>
								<span style="font-family: Courier, monospace">Courier</span>
							</label>
							<br>
							<label>
								<input class="fontsel" type="radio" name="font" value="'Special Elite', monospace">
								<span style="font-family: 'Special Elite', monospace">Special&nbsp;Elite</span>
							</label>
							<br>
							<label>
								<input class="fontsel" type="radio" name="font" value="'GNUTypewriterStandard', monospace" >
								<span style="font-family: 'GNUTypewriterStandard', monospace">GNUTypewriter</span>
							</label>
						</div>
					</div>
					<div class="control">
						<h4>
							Brokenness
						</h4>
						<div class="slider" id="ctrl_brokenness">
						</div>
						<div class="disp" id="disp_brokenness">
						</div>
					</div>
					<div class="control">
						<h4>
							Ribbon Ink
						</h4>
						<div class="slider" id="ctrl_inklevel">
						</div>
						<div class="disp" id="disp_inklevel">
						</div>
					</div>
				</div>
				<div style="clear:both"><!-- Ensures topbar height is set to height of contents -->
				</div>
			</div><!-- .topbar -->
			<div class="buttonbar">
				<div class="buttons left">
					<button onclick="stop()">Show instructions/info page</button>
				</div>
				<div class="buttons right">
					<button id="TopbarHide" onclick="topbar_hide()">Hide Controls</button>
					<button id="TopbarShow" onclick="topbar_show()" style="display: none">Show Controls</button>
				</div>
			</div><!-- .buttonbar -->
		</div><!-- .bars -->
		<div id="Carriage">
			<div class="output">
			</div>
		<div class="cursor"><img id="cursorImage" src="head.png"></div>
		</div>
		<!-- Warnings which may be displayed modally -->
		<div class="warning-rgba" style="display: none; font-size: 18px; color: red;">
			<b>You <em>really</em> need to upgrade your web browser.</b> OverType will not work on your browser because it does not support rgba() colours. They've been around for a long time now, so your browser must be pretty old. Using a very old web browser to surf the net means an ever-increasing number of sites will not work properly for you, and may be <em>unsafe</em> due to security holes which have long-since been fixed. Do yourself a favour and upgrade to a modern browser. 
		</div>
	</body>
</html>
